---
description: Tool System Architecture & Patterns - Comprehensive guide for implementing and maintaining the modular tool system
alwaysApply: false
---

# Tool System Architecture & Patterns

## When To Apply This Rule

- Creating new tools for tasks (Review Notebook, Document Vault, etc.)
- Implementing tool registration or assignment features
- Working with junction tables connecting tools to tasks/service lines
- Debugging tool-related Prisma queries or TypeScript types
- Integrating tools with the approval system
- Managing tool sub-tabs or tool metadata

## Core Principles

1. **Consistent Naming**: All Prisma relations use PascalCase matching model names
2. **Junction Tables**: Named as `[Entity1][Entity2]` (e.g., `TaskTool`, `ServiceLineTool`)
3. **User Relations**: Always use full descriptive relation names with format `User_[Model]_[field]ToUser`
4. **Foreign Keys**: All user ID references MUST have proper User relations, never plain strings if querying user data

## Prisma Schema Patterns

### Tool Entity Structure

**Main Entity**: `Tool`
- Fields: `id`, `name`, `code`, `description`, `icon`, `componentPath`, `active`, `sortOrder`
- Relations: `ServiceLineTool[]`, `TaskTool[]`, `ToolSubTab[]`

**Child Entity**: `ToolSubTab`
- Belongs to one Tool
- Has own: `id`, `name`, `code`, `icon`, `componentPath`, `active`, `sortOrder`

**Junction Tables**: `TaskTool`, `ServiceLineTool`
- Connect tools to tasks and service lines respectively

### Relation Naming Convention

**Format**: PascalCase matching the model name exactly

```prisma
model Tool {
  ServiceLineTool ServiceLineTool[]  // PascalCase, plural
  TaskTool        TaskTool[]         // PascalCase, plural
  ToolSubTab      ToolSubTab[]       // PascalCase, plural
}

model ToolSubTab {
  Tool Tool @relation(...)           // PascalCase, singular
}

model TaskTool {
  Tool Tool @relation(...)           // PascalCase, singular
  Task Task @relation(...)           // PascalCase, singular
  User User @relation(...)           // PascalCase, singular
}
```

### Junction Table Pattern

All junction tables MUST follow this structure:

```prisma
model TaskTool {
  id        Int      @id @default(autoincrement())
  taskId    Int      // Foreign key to Task
  toolId    Int      // Foreign key to Tool
  addedBy   String   // Foreign key to User
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations - all PascalCase
  User User @relation(fields: [addedBy], references: [id], onUpdate: NoAction)
  Task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  Tool Tool @relation(fields: [toolId], references: [id], onDelete: Cascade)
  
  // Constraints
  @@unique([taskId, toolId])
  @@index([taskId])
  @@index([toolId])
  @@index([addedBy])
  @@index([taskId, sortOrder])
}
```

**Key Requirements:**
- Auto-increment `id` primary key
- Foreign keys for both entities being joined
- `createdAt` and `updatedAt` timestamps
- Unique constraint on logical pair (prevents duplicates)
- Indexes on foreign keys and common query patterns
- `sortOrder` for ordered collections

### User Relation Pattern

**For multiple relations to same User entity, use descriptive relation names:**

```prisma
model ReviewNote {
  // Foreign key fields
  raisedBy         String
  assignedTo       String?
  
  // User relations - descriptive names prevent conflicts
  User_ReviewNote_raisedByToUser   User  @relation("ReviewNote_raisedByToUser", fields: [raisedBy], references: [id])
  User_ReviewNote_assignedToToUser User? @relation("ReviewNote_assignedToToUser", fields: [assignedTo], references: [id])
}

model User {
  // Reverse relations in User model
  ReviewNote_ReviewNote_raisedByToUser   ReviewNote[] @relation("ReviewNote_raisedByToUser")
  ReviewNote_ReviewNote_assignedToToUser ReviewNote[] @relation("ReviewNote_assignedToToUser")
}
```

**CRITICAL**: NEVER leave user ID fields as plain strings without relations if you need to query or display user data.

**Relation Naming Format**:
- Forward: `User_[Model]_[fieldName]ToUser`
- Reverse: `[Model]_[Model]_[fieldName]ToUser` (duplicated model name for uniqueness)
- Relation string: `"[Model]_[fieldName]ToUser"`

## Tool Registration Process

### 1. Code Structure

```
src/components/tools/
  ├── ToolRegistry.ts              # Client-side registry (imports components)
  ├── ToolRegistry.server.ts       # Server-side registry (for API/server use)
  ├── types.ts                     # Shared TypeScript interfaces
  └── {ToolName}/
      ├── index.tsx                # Main component export + config
      ├── components/              # Sub-components
      └── hooks/                   # Tool-specific hooks (optional)
```

### 2. Tool Component Interface

All tools MUST implement this interface:

```typescript
interface ToolComponentProps {
  taskId: string;              // Required: Task context
  toolId?: number;             // Optional: Specific tool instance ID
  subTabs?: Array<{            // Optional: Sub-tabs from DB
    id: number;
    name: string;
    code: string;
    icon?: string;
    sortOrder: number;
  }>;
  initialNoteId?: number;      // Optional: For deep linking
}

export type ToolComponent = React.ComponentType<ToolComponentProps>;
```

### 3. Tool Config Structure

Each tool MUST export a config:

```typescript
interface ToolModuleConfig {
  code: string;              // MUST match DB tool.code exactly
  name: string;              // Display name
  description: string;       // Brief description
  version: string;           // Semantic version
  defaultSubTabs?: Array<{   // Optional: Default sub-tabs for registration
    id: string;              // Code/identifier
    label: string;           // Display name
    icon: string;            // Icon name (lucide-react)
  }>;
}
```

**Example Tool Export**:

```typescript
// src/components/tools/ReviewNotebookTool/index.tsx
export const ReviewNotebookTool: ToolComponent = ({ taskId, toolId, subTabs, initialNoteId }) => {
  // Tool implementation
};

export const reviewNotebookToolConfig: ToolModuleConfig = {
  code: 'review-notebook',
  name: 'Review Notebook',
  description: 'Manage review notes and action items',
  version: '1.0.0',
  defaultSubTabs: [
    { id: 'notes', label: 'Notes', icon: 'FileText' },
    { id: 'categories', label: 'Categories', icon: 'Folder' },
  ],
};
```

### 4. Registration Steps

**Step 1: Create Tool Component**
1. Create directory: `src/components/tools/{ToolName}/`
2. Implement component following `ToolComponentProps` interface
3. Export component and config from `index.tsx`

**Step 2: Register in Code**
1. Import in `src/components/tools/ToolRegistry.ts`
2. Add to `TOOL_MODULES` array

**Step 3: Register in Database**
```bash
POST /api/tools/register
Body: { "code": "your-tool-code" }
```

**Step 4: Assign to Service Lines**
```bash
PUT /api/tools/[id]/assignments
Body: { "subServiceLineGroups": ["TAX-CORP", "TAX-INDIV"] }
```

**Step 5: Use on Tasks**
```bash
POST /api/tools/task/[taskId]
Body: { "toolId": 123, "sortOrder": 0 }
```

## API Patterns

### Tool Management Endpoints

**Tool CRUD**:
- `GET /api/tools` - List all tools (with optional `?active=true` filter)
- `POST /api/tools/register` - Register tool from code registry (preferred)
- `GET /api/tools/[id]` - Get tool details with counts
- `PUT /api/tools/[id]` - Update tool metadata
- `DELETE /api/tools/[id]` - Delete tool (fails if assigned to tasks)

**Service Line Assignments**:
- `GET /api/tools/[id]/assignments` - Get assigned service line groups
- `PUT /api/tools/[id]/assignments` - Update assignments (replaces all)

**Tool Discovery**:
- `GET /api/tools/available?subServiceLineGroup=TAX-CORP` - Get tools available for service line

**Task-Tool Relationship**:
- `GET /api/tools/task/[taskId]` - Get all tools assigned to task
- `POST /api/tools/task/[taskId]` - Add tool to task
- `DELETE /api/tools/task/[taskId]?toolId=X` - Remove tool from task

### API Response Pattern

All tool APIs return PascalCase relations matching Prisma:

```typescript
// GET /api/tools/[id]
{
  "data": {
    "id": 1,
    "name": "Review Notebook",
    "code": "review-notebook",
    "ToolSubTab": [              // PascalCase!
      { "id": 1, "name": "Notes", "code": "notes" }
    ],
    "ServiceLineTool": [         // PascalCase!
      { "subServiceLineGroup": "TAX-CORP" }
    ],
    "_count": {
      "TaskTool": 5,             // PascalCase!
      "ToolSubTab": 2,
      "ServiceLineTool": 3
    }
  }
}
```

## TypeScript Type Patterns

### Relation Names MUST Match Prisma Exactly

```typescript
// ✅ CORRECT - PascalCase matching schema
interface TaskTool {
  id: number;
  taskId: number;
  toolId: number;
  Tool: {              // PascalCase
    id: number;
    name: string;
    code: string;
    ToolSubTab?: {     // PascalCase
      id: number;
      name: string;
      code: string;
    }[];
  };
}

// Frontend usage
const toolName = taskTool.Tool.name;
const subTabs = taskTool.Tool.ToolSubTab;
```

## Integration with Approval System

### Approval-Tool Integration Pattern

When tools generate items requiring approval:

```typescript
import { approvalService } from '@/lib/services/approvals/approvalService';

// Step 1: Create the tool-specific item
const reviewNote = await prisma.reviewNote.create({
  data: { taskId, title: 'Review note requiring approval', raisedBy: user.id },
});

// Step 2: Create approval workflow
const approval = await approvalService.createApproval({
  workflowType: 'REVIEW_NOTE',
  workflowId: reviewNote.id,
  title: `Review note: ${reviewNote.title}`,
  requestedById: user.id,
  context: { taskId, categoryId: reviewNote.categoryId },
});

// Step 3: Link approval back to tool item
await prisma.reviewNote.update({
  where: { id: reviewNote.id },
  data: { approvalId: approval.id },
});

// Step 4: Invalidate caches
await invalidateApprovalsCache();
```

## Common Patterns & Best Practices

### ✅ DO: Follow Consistent Patterns

```typescript
// Correct relation access
const tool = await prisma.tool.findUnique({
  include: {
    ToolSubTab: true,        // PascalCase
    ServiceLineTool: true,   // PascalCase
  },
});

tool.ToolSubTab.forEach(subTab => {
  console.log(subTab.name);
});
```

### ❌ DON'T: Common Mistakes

**Relation Naming**:
```typescript
// ❌ Wrong: camelCase
const subTabs = taskTool.tool.subTabs;
// ✅ Correct: PascalCase
const subTabs = taskTool.Tool.ToolSubTab;
```

**User Relations**:
```prisma
// ❌ Wrong: Missing User relation
model ReviewNote {
  currentOwner String?
  // Missing: User relation!
}
```

**Cache Invalidation**:
```typescript
// ❌ Wrong: Missing cache invalidation
await prisma.taskTool.create({ data: { ... } });
// ✅ Correct: Invalidate cache
await invalidateOnTaskMutation(taskId);
```

## Validation Checklists

### Schema Requirements

- [ ] All user ID fields have corresponding User relations
- [ ] All relation names use PascalCase matching model names
- [ ] Junction tables follow `[Entity1][Entity2]` naming
- [ ] All foreign keys have proper indexes
- [ ] Unique constraints on logical pairs
- [ ] Timestamps on all tables
- [ ] Cascade deletes configured appropriately

### Code Requirements

- [ ] TypeScript types match Prisma relation names (PascalCase)
- [ ] Service layer uses explicit `select:` with PascalCase relations
- [ ] All mutations call appropriate cache invalidation
- [ ] API routes use `secureRoute` wrapper
- [ ] Input validation uses Zod schemas

### Tool-Specific Requirements

- [ ] Tool code is unique and matches registry
- [ ] Component implements `ToolComponentProps`
- [ ] Component path in DB points to valid module
- [ ] Tool registered in `ToolRegistry.ts`
- [ ] Service line assignments created before task assignment

## Related Rules

- **approval-system-rules.mdc**: Tool-approval integration patterns, workflow integration for tool-generated items
- **consolidated.mdc**: Database conventions, Prisma patterns, TypeScript rules, junction table patterns
- **security-rules.mdc**: API route security with `secureRoute`, feature permissions for tool access
- **forvis-design-rules.mdc**: Tool UI components, modal patterns, design system compliance

## Quick Reference

**Key Files**:
- `src/components/tools/ToolRegistry.ts` - Client-side tool registry
- `src/components/tools/types.ts` - Tool interfaces
- `src/app/api/tools/` - Tool management APIs

**Common Tasks**:
```typescript
// Register tool from code
POST /api/tools/register { code: "tool-code" }

// Assign to service lines
PUT /api/tools/[id]/assignments { subServiceLineGroups: ["TAX-CORP"] }

// Add to task
POST /api/tools/task/[taskId] { toolId: 123 }
```
