---
description: General AI patterns for Azure OpenAI integration
alwaysApply: false
---

# AI Patterns

Azure OpenAI integration for AI-powered generation, analysis, and document intelligence.

## Azure OpenAI Configuration

**Always import from `@/lib/ai/config`:**
- `models.mini`: GPT-5 Mini for generation tasks
- `models.nano`: Lightweight tasks (document extraction)
- `models.embedding`: Text embeddings for RAG/semantic search

**Model parameters**: Use `getModelParams()` for reasoning models (o1/o3/gpt-5) that don't support all parameters

## AI SDK Usage

**Text Generation:**
```typescript
import { generateText } from 'ai';
const result = await generateText({
  model: models.mini,
  prompt: 'Your prompt',
  ...getModelParams({ temperature: 0.7 })
});
```

**Structured Output:**
```typescript
import { generateObject } from 'ai';
const result = await generateObject({
  model: models.mini,
  schema: zodSchema,
  prompt: 'Your prompt'
});
```

**Streaming:**
```typescript
import { streamText } from 'ai';
const stream = await streamText({
  model: models.mini,
  prompt: 'Your prompt'
});
```

## Agent Orchestration

**Location:** `/src/lib/agents/`

**Pattern:** Multi-step AI workflows with phase-based coordination

**Agent Types:**
- Interview: Gather information via questions
- Research: Search and retrieve relevant data
- Analysis: Analyze and identify patterns/risks
- Drafting: Generate structured content
- Review: Quality assurance and feedback

**Rules:**
1. Sequential phase progression
2. Track state via `WorkflowState`
3. Pass conversation history between agents
4. Include phase metadata in responses

## RAG (Retrieval Augmented Generation)

**When to use:** Document-based AI tasks requiring context from uploaded files

**Location:** `/src/lib/services/opinions/ragEngine.ts`

**Pattern:**
1. Check `RAGEngine.isConfigured()` before use
2. Index documents: Automatic chunking (1000 chars, 200 overlap)
3. Search: `ragEngine.search(query, scopeId, { topK, minScore })`
4. Format context: `ragEngine.formatContext(results)`
5. Extract sources: `ragEngine.extractSources(results)`

**Backend:** Azure AI Search with vector embeddings (cosine similarity)

**Best Practices:**
- Always check availability
- Scope searches appropriately
- Return cited sources
- Fallback gracefully when unavailable

## Document Intelligence

**When to use:** Extract structured data from PDFs, images, documents

**Service:** `@/lib/services/documents/documentIntelligence`

**Returns:** Structured content, tables, key-value pairs

## Service Selection

1. **Agent Orchestrator** → Complex multi-step workflows
2. **Individual Agents** → Single-purpose AI tasks
3. **RAG Engine** → Document context retrieval
4. **Document Intelligence** → Structured extraction
5. **Direct AI SDK** → Simple generation/structured output

## Error Handling

**Always wrap AI calls:**
```typescript
try {
  const result = await generateText({ model, prompt });
  return result.text;
} catch (error) {
  logger.error('AI generation failed', { error });
  throw new Error('Failed to generate response');
}
```

## Logging

**Use structured logging:**
```typescript
import { logger } from '@/lib/utils/logger';
logger.info('AI operation', { agent, context });
logger.error('AI failed', { error: error.message, agent });
```

## Environment Variables

```bash
AZURE_OPENAI_API_KEY=your_key
AZURE_OPENAI_DEPLOYMENT=gpt-5-mini
AZURE_OPENAI_EMBEDDING_DEPLOYMENT=text-embedding-3-small
AZURE_SEARCH_ENDPOINT=https://resource.search.windows.net
AZURE_SEARCH_API_KEY=your_key
AZURE_SEARCH_INDEX_NAME=your-index
AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT=your_endpoint
AZURE_DOCUMENT_INTELLIGENCE_KEY=your_key
```

## Cost Optimization

1. Use `models.nano` for simple tasks
2. Set reasonable `maxTokens` limits
3. Cache repeated operations (`CacheService`)
4. Batch operations when possible
5. Stream long-form generation for UX

## Prompt Engineering

1. Be specific: Clear instructions
2. Provide context: Relevant background
3. Use examples: Few-shot prompting
4. Structure output: Request specific formats
5. Iterate: Refine based on quality
