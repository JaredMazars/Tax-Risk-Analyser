---
alwaysApply: true
---

# Architecture Patterns

Core architectural patterns and conventions for the Tax Calculation/Opinion Mapper project.

## Technology Stack

- **Framework**: Next.js 14 (App Router)
- **Language**: TypeScript (strict mode)
- **Database**: SQL Server (Azure SQL) / SQLite (dev)
- **ORM**: Prisma
- **Styling**: Tailwind CSS
- **State Management**: React Query (TanStack Query)
- **AI**: Azure OpenAI via Vercel AI SDK
- **Authentication**: Azure AD (MSAL)
- **Storage**: Azure Blob Storage
- **Search**: Azure AI Search (RAG)

## TypeScript Configuration

### Strict Mode

The project uses TypeScript strict mode with additional safety checks:

```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

**Follow these TypeScript practices:**

1. **No implicit any**: Always type your variables and parameters
2. **Null safety**: Check for undefined/null before accessing properties
3. **Array access**: Handle undefined when accessing array elements
4. **Return values**: Always return from all code paths

### Path Aliases

**Always use `@/*` imports** for src directory:

```typescript
// ✅ Correct
import { prisma } from '@/lib/db/prisma';
import { ProjectCard } from '@/components/features/projects/ProjectCard';
import { Project } from '@/types';

// ❌ Incorrect
import { prisma } from '../../../lib/db/prisma';
import { ProjectCard } from '../../components/features/projects/ProjectCard';
```

Configuration in `tsconfig.json`:
```json
{
  "paths": {
    "@/*": ["./src/*"]
  }
}
```

## Branded Types for Type Safety

Use branded types to prevent mixing different ID types at compile time.

### Available Branded Types (`types/branded.ts`)

```typescript
type ProjectId = number & { readonly __brand: 'ProjectId' };
type UserId = string & { readonly __brand: 'UserId' };
type DraftId = number & { readonly __brand: 'DraftId' };
type ClientId = number & { readonly __brand: 'ClientId' };
type AdjustmentId = number & { readonly __brand: 'AdjustmentId' };
type DocumentId = number & { readonly __brand: 'DocumentId' };
```

### Using Branded Types

```typescript
import { toProjectId, ProjectId } from '@/types/branded';

// Convert from unknown/any to branded type
const projectId = toProjectId(params.id); // Validates and brands

// Type-safe function
function getProject(id: ProjectId) {
  // id is guaranteed to be a valid project ID
}

// This won't compile - prevents mixing IDs
const userId: UserId = getUserId();
getProject(userId); // ❌ Type error
```

### When to Use Branded Types

- API route parameters (IDs from URL)
- Database queries with IDs
- Function parameters that expect specific ID types
- Prevents accidentally passing wrong ID type

## Validation with Zod

**All user input must be validated** using Zod schemas.

### Schema Location

Define validation schemas in `/src/lib/validation/schemas.ts`:

```typescript
import { z } from 'zod';

export const CreateProjectSchema = z.object({
  name: z.string().min(1).max(200),
  description: z.string().max(1000).nullable().optional(),
  projectType: z.enum(['TAX_CALCULATION', 'TAX_OPINION', 'TAX_ADMINISTRATION']),
  taxYear: z.number().int().min(2000).max(2100).optional(),
  clientId: z.number().int().positive().nullable().optional(),
}).strict();

export const UpdateProjectSchema = CreateProjectSchema.partial();
```

### Validating Input

```typescript
import { CreateProjectSchema } from '@/lib/validation/schemas';

// In API route
const body = await request.json();
const validated = CreateProjectSchema.parse(body); // Throws if invalid

// Or with safeParse for custom error handling
const result = CreateProjectSchema.safeParse(body);
if (!result.success) {
  return NextResponse.json(
    { success: false, error: 'Invalid input', details: result.error },
    { status: 400 }
  );
}
```

### Validation Best Practices

1. **Use strict()**: Reject unknown properties
2. **Specific error messages**: Use `.min()`, `.max()`, `.email()`, etc.
3. **Type inference**: Use `z.infer<typeof Schema>` for TypeScript types
4. **Reuse schemas**: Create partial schemas for updates

## Database Access

### Prisma Client

**Always use the singleton instance** from `@/lib/db/prisma`:

```typescript
import { prisma } from '@/lib/db/prisma';

// Query
const projects = await prisma.project.findMany({
  where: { userId },
  include: { client: true }
});

// Create
const project = await prisma.project.create({
  data: { name, userId, projectType }
});

// Update
const updated = await prisma.project.update({
  where: { id: projectId },
  data: { name }
});

// Delete
await prisma.project.delete({
  where: { id: projectId }
});
```

### Database Best Practices

1. **Use transactions** for multi-step operations:
   ```typescript
   await prisma.$transaction(async (tx) => {
     await tx.project.update({ ... });
     await tx.auditLog.create({ ... });
   });
   ```

2. **Select only needed fields**:
   ```typescript
   const projects = await prisma.project.findMany({
     select: { id: true, name: true, createdAt: true }
   });
   ```

3. **Use proper indexes**: Ensure frequently queried fields are indexed in schema
4. **Handle not found**: Check for null results
5. **Avoid N+1 queries**: Use `include` or `select` with nested relations

## Error Handling

### AppError Class

Use `AppError` for throwing structured errors:

```typescript
import { AppError, ErrorCodes } from '@/lib/utils/errorHandler';

// Throw structured error
throw new AppError(
  404,
  'Project not found',
  ErrorCodes.NOT_FOUND,
  { projectId }
);

// Common error codes
ErrorCodes.VALIDATION_ERROR    // 400
ErrorCodes.UNAUTHORIZED        // 401
ErrorCodes.FORBIDDEN          // 403
ErrorCodes.NOT_FOUND          // 404
ErrorCodes.CONFLICT           // 409
ErrorCodes.INTERNAL_ERROR     // 500
```

### API Route Error Handling

Use `handleApiError` for consistent error responses:

```typescript
import { handleApiError } from '@/lib/utils/errorHandler';

export async function GET(request: NextRequest) {
  try {
    // Route logic
    return NextResponse.json({ success: true, data });
  } catch (error) {
    return handleApiError(error, 'GET /api/projects');
  }
}
```

Error response format:
```json
{
  "success": false,
  "error": "Human-readable error message",
  "code": "ERROR_CODE",
  "details": {} // Only in development
}
```

### Error Handling Best Practices

1. **Always catch errors** in API routes
2. **Use try-catch** around database operations
3. **Log errors** with context
4. **User-friendly messages** (don't expose internal details in production)
5. **Specific error codes** for client-side error handling

## Service Layer Pattern

Business logic lives in `/src/lib/services/<domain>/`.

### Service Organization

```
services/
├── auth/
│   ├── auth.ts              # Session management
│   └── graphClient.ts       # Microsoft Graph API
├── documents/
│   ├── blobStorage.ts       # Azure Blob operations
│   ├── documentExtractor.ts # Document processing
│   └── documentIntelligence.ts
├── export/
│   ├── excelExporter.ts
│   ├── pdfExporter.ts
│   └── wordExporter.ts
├── opinions/
│   ├── aiTaxReportGenerator.ts
│   ├── ragEngine.ts
│   └── sectionMapper.ts
└── tax/
    ├── taxAdjustmentEngine.ts
    └── taxAdjustmentsGuide.ts
```

### Service Pattern

Services are typically **classes** or **modules with exported functions**:

```typescript
// Class-based service
export class RAGEngine {
  private searchClient: SearchClient;
  
  constructor() {
    // Initialize
  }
  
  async search(query: string) {
    // Implementation
  }
}

// Function-based service
export async function uploadToBlob(
  file: Buffer,
  fileName: string
): Promise<string> {
  // Implementation
}
```

### Service Guidelines

1. **Pure business logic**: No request/response handling
2. **Reusable**: Called from multiple API routes or other services
3. **Testable**: Easy to unit test
4. **Domain-focused**: Group related functionality
5. **Error propagation**: Throw AppError, let caller handle

## State Management

### React Query (TanStack Query)

**Use React Query for all server state**:

```typescript
// Define hook in /src/hooks/<domain>/
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

export function useProjectData(projectId: number) {
  return useQuery({
    queryKey: ['project', projectId],
    queryFn: async () => {
      const response = await fetch(`/api/projects/${projectId}`);
      if (!response.ok) throw new Error('Failed to fetch');
      return response.json();
    },
  });
}

export function useCreateProject() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (data: CreateProjectData) => {
      const response = await fetch('/api/projects', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
      if (!response.ok) throw new Error('Failed to create');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['projects'] });
    },
  });
}
```

### React Query Best Practices

1. **Query keys**: Use arrays with descriptive keys
2. **Invalidation**: Invalidate queries after mutations
3. **Error handling**: React Query handles errors automatically
4. **Loading states**: Use `isLoading`, `isError` states
5. **Optimistic updates**: For better UX (optional)

### Local State

Use React `useState` for:
- Form state (before submission)
- UI state (modals, dropdowns, toggles)
- Component-specific temporary state

**Don't** use local state for:
- Server data (use React Query)
- Global app state (use React Query or Context)

## API Response Format

### Consistent Response Structure

```typescript
// Success response
{
  "success": true,
  "data": { ... }
}

// Error response
{
  "success": false,
  "error": "Error message",
  "code": "ERROR_CODE"
}
```

### Type-Safe Responses

Define response types in `/src/lib/api/types.ts`:

```typescript
export interface ApiResponse<T> {
  success: true;
  data: T;
} | {
  success: false;
  error: string;
  code?: string;
  details?: unknown;
}
```

## Environment Variables

### Configuration

Define and validate environment variables in `/src/lib/config/env.ts`:

```typescript
import { validateEnvVariables } from '@/lib/utils/errorHandler';

// Validate on startup
validateEnvVariables([
  'DATABASE_URL',
  'NEXTAUTH_SECRET',
  'AZURE_AD_CLIENT_ID',
  'AZURE_OPENAI_API_KEY',
]);

export const env = {
  database: {
    url: process.env.DATABASE_URL!,
  },
  auth: {
    secret: process.env.NEXTAUTH_SECRET!,
    azureClientId: process.env.AZURE_AD_CLIENT_ID!,
  },
  // ...
};
```

### Environment Variable Guidelines

1. **Validate early**: Check required vars at startup
2. **Type safety**: Use `!` assertion after validation
3. **Grouping**: Organize by feature/service
4. **Documentation**: Document required vars in .env.example
5. **No defaults for secrets**: Always require explicit configuration

## Logging

### Winston Logger

Use structured logging with Winston:

```typescript
import { logger } from '@/lib/utils/logger';

// Info
logger.info('Project created', {
  projectId,
  userId,
  projectType
});

// Error
logger.error('Failed to generate report', {
  error: error.message,
  projectId
});

// Warning
logger.warn('Rate limit approaching', {
  userId,
  requestCount
});
```

### Logging Best Practices

1. **Structured data**: Use objects for context
2. **Appropriate levels**: info, warn, error
3. **Sensitive data**: Don't log secrets or PII
4. **Error context**: Include relevant IDs and state
5. **Performance**: Don't log in tight loops

## Next.js App Router Patterns

### Server Components (Default)

Most components should be Server Components:

```typescript
// No 'use client' directive = Server Component
export default async function ProjectPage({ params }) {
  const project = await prisma.project.findUnique({
    where: { id: Number(params.id) }
  });
  
  return <div>{project.name}</div>;
}
```

### Client Components

Add `'use client'` when needed:

```typescript
'use client';

import { useState } from 'react';

export function InteractiveComponent() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;
}
```

### API Routes (App Router)

```typescript
// app/api/projects/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  // GET handler
}

export async function POST(request: NextRequest) {
  // POST handler
}

// app/api/projects/[id]/route.ts
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  // Handler with dynamic route
}
```

## Security Patterns

1. **Authentication**: Check user session in API routes
2. **Authorization**: Verify project access before operations
3. **Input validation**: Validate all user input with Zod
4. **SQL injection**: Use Prisma (parameterized queries)
5. **CSRF**: Next.js handles CSRF protection
6. **Rate limiting**: Implement for public endpoints
7. **Secrets**: Never expose in client code

## Performance Patterns

1. **React Query caching**: Automatic caching of server data
2. **Server Components**: Reduce client bundle size
3. **Dynamic imports**: Code split heavy components
4. **Image optimization**: Use Next.js Image component
5. **Database indexes**: Index frequently queried fields
6. **Pagination**: Implement for large datasets
7. **Streaming**: Use streaming for large AI responses

## Summary

- Use TypeScript strict mode with branded types
- Validate all input with Zod schemas
- Use Prisma singleton for database access
- Implement service layer for business logic
- Use React Query for server state
- Consistent error handling with AppError
- Always use `@/` imports
- Structure logging with Winston
- Follow Next.js App Router conventions
