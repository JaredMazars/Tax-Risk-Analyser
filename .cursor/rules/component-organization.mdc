---
alwaysApply: true
---

# Component Organization

This project follows a **feature-based component architecture**. Components are organized by domain and purpose, ensuring scalability and maintainability.

## Directory Structure

```
/src/components/
├── features/          # Feature-specific components
├── layout/            # Layout components
├── shared/            # Reusable cross-feature components
├── ui/                # Base UI components (shadcn/ui, etc.)
└── Providers.tsx      # React Query and context providers
```

## Feature Components (`components/features/`)

Feature components are **domain-specific** and should be grouped by the feature they support.

### Existing Feature Domains

```
features/
├── clients/           # Client management components
├── opinions/          # Tax opinion drafting components
├── projects/          # Project management components
├── reports/           # Financial report viewers
└── tax-adjustments/   # Tax adjustment components
```

### Rules for Feature Components

1. **Create subdirectories for complex features**: If a feature has multiple related components, create a subdirectory

   ```
   Good:
   features/
   └── opinions/
       └── OpinionAssistant/
           ├── ChatInterface.tsx
           ├── DocumentManager.tsx
           ├── OpinionPreview.tsx
           └── SectionEditor.tsx

   Also acceptable for simple features:
   features/
   └── clients/
       └── ClientSelector.tsx
   ```

2. **Component naming**: Use descriptive PascalCase names that clearly indicate purpose
   - ✅ `CreateProjectModal.tsx`
   - ✅ `ProjectTypeSelector.tsx`
   - ✅ `TaxAdjustmentCard.tsx`
   - ❌ `Modal.tsx` (too generic)
   - ❌ `ProjectComponent.tsx` (redundant suffix)

3. **When to create a new feature domain**:
   - Multiple related components (3+)
   - Distinct business domain
   - Isolated state/logic
   
   Examples:
   - `compliance/` - if adding compliance-specific features
   - `analytics/` - for analytics dashboards
   - `workflows/` - for workflow management

4. **Feature-specific hooks**: Co-locate hooks with their features when they're not reusable

   ```
   features/
   └── opinions/
       └── OpinionAssistant/
           ├── ChatInterface.tsx
           ├── useOpinionChat.ts     # ✅ Feature-specific hook
           └── ...
   ```

### Feature Component Guidelines

- **Props**: Use TypeScript interfaces, export if reusable
- **State**: Keep local state in components; lift to parent or React Query for shared state
- **Server data**: Always use React Query hooks (in `/src/hooks/`)
- **Imports**: Use `@/` path alias for all imports

Example feature component:

```typescript
// features/projects/CreateProjectModal.tsx
import { useState } from 'react';
import { Dialog } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { useCreateProject } from '@/hooks/projects/useCreateProject';

interface CreateProjectModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export function CreateProjectModal({ isOpen, onClose }: CreateProjectModalProps) {
  const [formData, setFormData] = useState({...});
  const createProject = useCreateProject();

  // Component implementation
}
```

## Shared Components (`components/shared/`)

Shared components are **reusable across multiple features**.

### Current Shared Components

```
shared/
├── CalculationBreakdown.tsx     # Tax calculation display
├── DocumentUploader.tsx         # File upload with Azure Blob
├── ExportMenu.tsx               # Export options dropdown
├── ExtractionResults.tsx        # Document extraction results
├── FileUpload.tsx               # Generic file upload
├── ProcessingModal.tsx          # Processing status modal
├── StatusBadge.tsx              # Status indicator
└── TaxYearInput.tsx             # Tax year selector
```

### When to Create Shared Components

Move a component to `shared/` when:
- Used by 2+ different features
- Generic enough to be reusable
- No feature-specific business logic

**Do not prematurely abstract**. Start in a feature directory; extract to shared when reuse is needed.

### Shared Component Guidelines

1. **Make them configurable**: Use props for customization
2. **Minimal dependencies**: Avoid importing from feature directories
3. **Generic naming**: Names should reflect **what** they do, not **where** they're used
   - ✅ `FileUpload`, `StatusBadge`, `DocumentUploader`
   - ❌ `ProjectFileUpload`, `ClientStatusBadge`

Example shared component:

```typescript
// components/shared/StatusBadge.tsx
interface StatusBadgeProps {
  status: 'pending' | 'approved' | 'rejected';
  label?: string;
}

export function StatusBadge({ status, label }: StatusBadgeProps) {
  // Generic status badge usable anywhere
}
```

## Layout Components (`components/layout/`)

Layout components structure the application UI.

### Current Layout Components

```
layout/
├── DashboardNav.tsx      # Main navigation sidebar/header
└── UserMenu.tsx          # User dropdown menu
```

### When to Create Layout Components

- Application-wide navigation
- Headers, footers, sidebars
- Page wrappers or shells
- Not page-specific; used across multiple pages

Layout components typically live in `/src/app/*/layout.tsx` but extract reusable parts to `components/layout/`.

## UI Components (`components/ui/`)

Base-level UI components (typically from component libraries like shadcn/ui).

### Guidelines

- **Library components**: shadcn/ui and similar go here
- **Minimal customization**: Keep them generic and reusable
- **No business logic**: Pure presentation components
- **Follow library conventions**: Use library naming and structure

Examples: `Button`, `Dialog`, `Input`, `Select`, `Card`, `Table`

## Component Hierarchy

When deciding where to place a component, follow this decision tree:

```
Is it a base UI element (button, input, dialog)?
└─ YES → components/ui/

Is it part of the layout structure (nav, header)?
└─ YES → components/layout/

Is it used by multiple features with no feature-specific logic?
└─ YES → components/shared/

Is it specific to a single feature domain?
└─ YES → components/features/<domain>/

Still unsure?
└─ Start in features/, move to shared/ when reused
```

## Import Patterns

### Always Use Path Alias

```typescript
// ✅ Correct
import { Button } from '@/components/ui/button';
import { ProjectCard } from '@/components/features/projects/ProjectCard';
import { useProjectData } from '@/hooks/projects/useProjectData';
import { ROUTES } from '@/constants/routes';

// ❌ Incorrect
import { Button } from '../../../ui/button';
import { ProjectCard } from './ProjectCard';
```

### Import Order

Follow this order (enforced by linter):

1. React and Next.js imports
2. Third-party libraries
3. @/ aliased imports (components, lib, types, etc.)
4. Relative imports (same directory)
5. CSS imports

```typescript
// 1. React/Next
import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

// 2. Third-party
import { Dialog } from '@headlessui/react';

// 3. @/ imports
import { Button } from '@/components/ui/button';
import { useProjectData } from '@/hooks/projects/useProjectData';
import { Project } from '@/types';

// 4. Relative
import { ProjectCard } from './ProjectCard';

// 5. CSS
import styles from './styles.module.css';
```

## Component Files

### File Structure

Each component file should typically contain:

```typescript
// 1. Imports
import { ... } from '...';

// 2. Types/Interfaces (if not exported from elsewhere)
interface ComponentProps {
  // ...
}

// 3. Component
export function Component({ ...props }: ComponentProps) {
  // Implementation
}

// 4. Helper functions (if small and component-specific)
function helperFunction() {
  // ...
}
```

### Exporting

- **Default exports**: Avoid for components (makes refactoring harder)
- **Named exports**: Preferred for components
- **Export types**: Export interfaces if they might be used by consumers

```typescript
// ✅ Preferred
export function ProjectCard({ project }: ProjectCardProps) { ... }
export interface ProjectCardProps { ... }

// ❌ Avoid
export default ProjectCard;
```

## Server vs Client Components

Next.js App Router default: **Server Components**

### When to Use Client Components

Mark with `'use client'` directive when component:
- Uses React hooks (useState, useEffect, etc.)
- Handles browser events (onClick, onChange, etc.)
- Uses browser-only APIs
- Uses React Query hooks

```typescript
'use client';

import { useState } from 'react';

export function InteractiveComponent() {
  const [count, setCount] = useState(0);
  // ...
}
```

### When to Keep as Server Component

- Static content
- Data fetching (can be done server-side)
- No interactivity
- Layout components (unless they need client features)

**Rule of thumb**: Start with Server Components, add `'use client'` only when needed.

## Testing (Future)

When adding tests, co-locate them with components:

```
features/
└── projects/
    ├── ProjectCard.tsx
    └── ProjectCard.test.tsx
```

## Component Best Practices

1. **Single Responsibility**: One component, one purpose
2. **Composability**: Build larger components from smaller ones
3. **Props over children**: Be explicit about what a component needs
4. **Controlled components**: Prefer controlled over uncontrolled components
5. **Error boundaries**: Use for feature sections that might fail
6. **Loading states**: Always handle loading and error states
7. **Accessibility**: Use semantic HTML and ARIA attributes

## Examples

### Creating a New Feature Component

Scenario: Adding a compliance checklist feature

```
1. Create feature directory:
   components/features/compliance/

2. Add components:
   components/features/compliance/
   ├── ComplianceChecklist.tsx
   ├── ComplianceItem.tsx
   └── ComplianceProgress.tsx

3. If needed, add feature-specific hook:
   hooks/compliance/
   └── useComplianceData.ts
```

### Extracting to Shared Component

Scenario: `FileUpload` used in 3+ features

```
1. Move from feature to shared:
   features/projects/FileUpload.tsx
   → shared/FileUpload.tsx

2. Make it more generic (remove feature-specific code)

3. Update imports in consuming components

4. Ensure it's configurable via props
```

## Summary

- **features/**: Feature-specific, domain-grouped components
- **shared/**: Reusable cross-feature components
- **layout/**: Application structure components
- **ui/**: Base UI library components
- Use `@/` imports, named exports, and place new feature code in appropriate feature directories
