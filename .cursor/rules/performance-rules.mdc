---
alwaysApply: true
version: 1.2.0
lastUpdated: 2026-02-06
description: Performance optimization patterns for imports, database queries, caching, request handling, and resilience - mandatory requirements for all files
changelog:
  - "1.2.0 (2026-02-06): Added Resilience section (timeouts, retry, circuit breaker, graceful degradation) to align with route review standards"
  - "1.1.0 (2026-01-24): Changed to always applied - explicit select, logger usage, and static imports are required everywhere"
  - "1.0.0 (2026-01-24): Initial performance patterns documentation"
---

# Performance Optimization Rules

React Query + Redis Caching | Database Optimization | Request Handling

## Imports

- **Static imports ONLY** at top of file - NO `await import()` in handlers
- Exception: AI/ML dependencies may use lazy loading for bundle size

## Database

- ALWAYS explicit `select:` fields
- Batch queries: `Promise.all()`
- Transactions (`prisma.$transaction`) for multi-step mutations
- Prevent N+1 queries
- Default limits on `findMany()` - no unbounded queries on large tables
- Deterministic ordering for pagination (cursor or stable `orderBy` with secondary sort)

## Request Handling

- Large payloads: paginate or stream responses
- External API calls: parallelize with `Promise.all()` + set timeouts
- Race conditions: use optimistic locking or transactions for concurrent mutations
- Response size: bound large JSON responses

## Caching Strategy

**Hybrid Approach:** React Query (client-side) + Redis (server-side)

**React Query (Client-Side):**
- Entity details (tasks, clients, groups, employees)
- List data with pagination
- Automatic invalidation on mutations
- Cache keys: `['tasks', taskId]`, `['clients', clientId]`

**Redis/Memory Cache (Server-Side):**
- **Sessions** (1h) - User authentication sessions
- **Permissions** (10min) - User feature/role permissions
- **Rate Limiting** (varies) - Per-user and per-IP rate limits
- **Analytics** (30min) - Workspace counts, graphs, aggregations
- **Planner Data** (5-30min) - Staff planner queries (expensive joins)
- **Service Lines** (10min) - Service line mappings and metadata
- **Client Acceptance** (10min) - Server-side validation data
- **Document Vault** (10min) - Vault metadata
- **Employee Lookups** (10min) - Employee data for relationships

**When to Use Which:**
- **React Query:** Entity CRUD, lists, user-specific data
- **Redis:** Shared state, expensive aggregations, rate limiting, sessions

**Cache Invalidation (after mutations):**
```typescript
import { invalidateApprovalsCache, invalidateWorkspaceCounts, invalidatePlannerCachesForServiceLine } from '@/lib/services/cache/cacheInvalidation';

// After approval mutations
await invalidateApprovalsCache();

// After task/client mutations affecting counts
await invalidateWorkspaceCounts(serviceLine, subServiceLineGroup);

// After task team mutations (invalidates planner)
await invalidatePlannerCachesForServiceLine(serviceLine, subServiceLineGroup);

// React Query invalidation (client-side)
queryClient.invalidateQueries({ queryKey: ['tasks', taskId] });
queryClient.invalidateQueries({ queryKey: ['clients', clientId] });
```

**List Caching:** Only first 3 pages cached (5min TTL), searches skipped.

**Performance:** Uses SCAN (not KEYS) for pattern invalidation, silent failure on cache errors.

## Resilience

For routes or services that call external APIs (Azure OpenAI, Microsoft Graph, blob storage, etc.):

- **Timeouts** - All external API calls MUST have explicit timeouts (30-60s max)
- **Retry with backoff** - Transient failures (429, 503) retry with exponential backoff + jitter
  - Use `retryUtils.ts` from `@/lib/utils/retryUtils` for standardized retry logic
- **Graceful degradation** - When dependencies are unavailable, return cached/default responses instead of failing
- **Circuit breaker** - Frequently-failing external services should be circuit-broken to prevent cascading failures
- **Fallback values** - Non-critical data (analytics, AI suggestions) should fall back to cached or empty state
- **Dead letter handling** - Failed async operations (queue workers, email) must be logged and retryable

```typescript
// Example: External API call with timeout and retry
import { withRetry } from '@/lib/utils/retryUtils';

const result = await withRetry(
  () => externalApiCall({ timeout: 30000 }),
  { maxRetries: 3, baseDelay: 1000, maxDelay: 10000 }
);
```

## Logging

```typescript
import { logger } from '@/lib/utils/logger';
logger.info('Action completed', { userId, taskId });
logger.warn('Unusual condition', { details });
logger.error('Operation failed', error);
// NEVER use console.log/warn/error in production code
```
