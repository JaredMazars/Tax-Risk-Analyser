---
alwaysApply: true
---

# Project Conventions

Next.js 14 (App Router) | TypeScript (strict) | Prisma | React Query | Azure OpenAI | Azure AD

## Specialized Rule Files (When To Consult)

**ALWAYS consult these files for their specific domains:**

### `.cursor/rules/forvis-design-rules.mdc` (CRITICAL)
**When:** Building ANY UI components, modals, forms, cards, or interactive elements
**Key Rules:** 
- NEVER use browser dialogs (`confirm()`, `alert()`, `prompt()`)
- Use `@/components/ui` imports for all UI components
- Follow gradient registry for backgrounds and styling
- Use Banner component (NOT toast libraries like sonner/react-toastify)

### `.cursor/rules/security-rules.mdc` (REQUIRED)
**When:** Creating API routes, implementing page permissions, or access control
**Key Rules:**
- ALL API routes MUST use `secureRoute` wrapper
- Use `<PageAccessGuard>` for page protection
- Use `<FeatureGate>` for conditional UI rendering
- Follow 4-tier permission lookup (Cache → DB → Code → Convention)

### `.cursor/rules/approval-system-rules.mdc`
**When:** Implementing ANY workflow requiring approval (acceptance, engagement letters, change requests, DPA, review notes)
**Key Rules:**
- Use centralized `approvalService.createApproval()`
- Register workflow type in `workflowRegistry.ts`
- ALWAYS call `invalidateApprovalsCache()` after mutations
- Use `UnifiedApprovalCard` for UI display

### `.cursor/rules/ai-patterns.mdc`
**When:** Using Azure OpenAI, document intelligence, RAG, or AI agents
**Key Rules:**
- Import models from `@/lib/ai/config`
- Use `secureRoute.ai()` for AI endpoints (strict rate limiting)
- Check `RAGEngine.isConfigured()` before use
- Follow service selection hierarchy (orchestrator → individual agents → RAG → direct SDK)

### `.cursor/rules/blob-storage-rules.mdc`
**When:** Uploading files to Azure Blob Storage or creating new document storage features
**Key Rules:**
- MUST use purpose-specific containers (never mix document types)
- Follow naming: `{purpose}` or `{purpose}-{category}`
- Path structure: `{entityId}/{timestamp}_{sanitized_filename}`
- Create dedicated container client for each document type

### `.cursor/rules/tool-system-rules.mdc`
**When:** Creating tools, working with junction tables, or tool-task relationships
**Key Rules:**
- All Prisma relations MUST use PascalCase matching model names
- Junction tables: `[Entity1][Entity2]` naming pattern
- User relations: Use descriptive names `User_[Model]_[field]ToUser`
- Tools integrate with approval system for items requiring approval

## TypeScript

**Type Organization:** Prisma Schema -> `types/index.ts` -> derive DTOs with Partial/Pick/Omit
- `types/branded.ts`: Branded ID types | `types/dto.ts`: DTOs | `types/api.ts`: API types

**Requirements:**
- Strict mode, `@/*` imports, ALL IDs use branded types
- Route params via `parseXxxId()` utilities
- Define enums ONCE in `types/index.ts` (e.g., `SystemRole`, `ServiceLineRole`)
- `undefined` for optional, `null` for database nulls
- **NO `any` types** - Use `unknown`, `Record<string, unknown>`, or proper interfaces
- All input validated via Zod schemas in `/src/lib/validation/schemas.ts`

## Database

**Dual-ID Convention:**
- **Internal IDs** (`id`): Auto-increment PKs for internal-only tables (TaskTeam, BDOpportunity)
- **External IDs** (`GS*`): GUIDs for external system tables (Client, Task, Employee, Wip)
- **Codes** (`*Code`): Display/search ONLY, NEVER for relationships

**Query Patterns:**
```typescript
// External tables: use GS* for relationships
const tasks = await prisma.task.findMany({ where: { GSClientID: client.GSClientID } });

// Internal tables: use id
const team = await prisma.taskTeam.findMany({ where: { taskId: task.id } });

// Codes: search only
const clients = await prisma.client.findMany({ where: { clientCode: { contains: term } } });
```

**SQL Server Case Sensitivity:**
- **NEVER use `mode: 'insensitive'`** - not supported by SQL Server (PostgreSQL/MySQL only)
- SQL Server uses collation-based case sensitivity (default: `SQL_Latin1_General_CP1_CI_AS` is case-insensitive)
- Use `contains`, `startsWith`, `endsWith` without mode parameter for case-insensitive searches

**Data Model Relationships (CRITICAL):**
- **Clients are unique to Groups**: Each client belongs to exactly one group (`groupCode`). When creating/updating APIs that work with clients, always validate that the client belongs to the specified group.
- **Tasks are unique to Clients**: Each task belongs to exactly one client (`GSClientID`). When creating/updating APIs that work with tasks, always validate that the task belongs to the specified client.

```typescript
// Example: Validate task belongs to client in API
const task = await prisma.task.findUnique({
  where: { id: taskId },
  select: { GSClientID: true }
});
if (task?.GSClientID !== clientId) {
  throw new AppError(404, 'Task not found', ErrorCodes.NOT_FOUND);
}

// Example: Validate client belongs to group in API
const client = await prisma.client.findUnique({
  where: { GSClientID: clientId },
  select: { groupCode: true }
});
if (client?.groupCode !== groupCode) {
  throw new AppError(404, 'Client not found', ErrorCodes.NOT_FOUND);
}
```

**Fiscal Period Filtering (REQUIRED):**
- **Fiscal Year:** September to August (FY2024 = Sep 2023 - Aug 2024)
- **ALWAYS use fiscal period helpers** from `@/lib/services/reports/fiscalPeriodQueries` for date filtering
- **NEVER manually calculate** fiscal periods - use provided utilities
- **Available on transaction tables:** `WIPTransactions`, `DrsTransactions`, `Wip`, `Debtors`, `WIPAging`

```typescript
import { buildFiscalPeriodFilter, getFiscalPeriods } from '@/lib/services/reports/fiscalPeriodQueries';
import { getFiscalYear, formatFiscalPeriod } from '@/lib/utils/fiscalPeriod';

// Server-side: Filter transactions by fiscal period
const where = buildFiscalPeriodFilter(
  { fiscalYear: 2024, fiscalQuarter: 2 },
  'TranDate' // date field name
);
const transactions = await prisma.wIPTransactions.findMany({ where });

// Client-side: Get fiscal year from date
const fiscalYear = getFiscalYear(new Date()); // Returns 2024

// Get available fiscal periods for dropdowns
const years = await getFiscalPeriods({ groupBy: 'year' });
const quarters = await getFiscalPeriods({ fiscalYear: 2024, groupBy: 'quarter' });
```

**SQL Functions Available:**
- `dbo.GetFiscalYear(date)` - Returns fiscal year (e.g., 2024)
- `dbo.GetFiscalQuarter(date)` - Returns quarter 1-4
- `dbo.GetFiscalMonth(date)` - Returns fiscal month 1-12 (1=Sep, 12=Aug)
- `dbo.GetFiscalPeriodKey(date)` - Returns period key for joins

**Documentation:** See `docs/FISCAL_PERIOD_USAGE.md` for complete guide

## Service Lines

**Client-Facing:** TAX, AUDIT, ACCOUNTING, ADVISORY
**Shared Services:** QRM, BUSINESS_DEV, IT, FINANCE, HR, COUNTRY_MANAGEMENT

**Tables:**
- `ServiceLineMaster`: Application master list (code, name, active)
- `ServiceLineExternal`: Maps `ServLineCode` -> `SubServlineGroupCode` -> `masterCode`
- `ServiceLineUser`: User assignments to `subServiceLineGroup` with `role`

**Access Pattern:** Task's `ServLineCode` -> `SubServlineGroupCode` -> check user's `ServiceLineUser` assignments

**URL:** `/dashboard/[serviceLine]/[subServiceLineGroup]/clients/[id]/tasks/[taskId]`

## Security (CRITICAL)

### Role Model

1. **System**: `SYSTEM_ADMIN` > `USER`
2. **Service Line**: `ADMINISTRATOR` > `PARTNER` > `MANAGER` > `SUPERVISOR` > `USER` > `VIEWER`

Roles defined in `@/lib/utils/roleHierarchy.ts`. SYSTEM_ADMIN bypasses all checks.

### API Routes - Use secureRoute (REQUIRED)

All API routes MUST use the `secureRoute` wrapper from `@/lib/api/secureRoute.ts`:

```typescript
import { secureRoute, Feature } from '@/lib/api/secureRoute';

// Mutations (POST/PUT/PATCH/DELETE)
export const POST = secureRoute.mutation({
  feature: Feature.MANAGE_TASKS,
  schema: CreateTaskSchema,
  handler: async (request, { user, data }) => {
    const result = await prisma.task.create({ data, select: { id: true } });
    return NextResponse.json(successResponse(result));
  },
});

// Queries (GET)
export const GET = secureRoute.query({
  feature: Feature.ACCESS_TASKS,
  handler: async (request, { user }) => {
    return NextResponse.json(successResponse(data));
  },
});

// Routes with params (e.g., [id])
export const GET = secureRoute.queryWithParams({
  taskIdParam: 'id',
  handler: async (request, { user, params }) => { ... },
});

// AI endpoints (strict rate limiting)
export const POST = secureRoute.ai({ schema, handler });

// File uploads
export const POST = secureRoute.fileUpload({ handler });
```

**secureRoute handles automatically:**
- Authentication, Rate limiting (per-user + IP), Input sanitization, Zod validation, Error handling, Performance tracking

**Developer responsibilities:**
- Choose correct wrapper (`mutation`, `query`, `ai`, `fileUpload`)
- Specify `feature` for authorization
- Use explicit `select:` in Prisma queries
- Call cache invalidation after mutations
- Use `logger` (NOT `console.*`)

### Page-Level Access

**Comprehensive documentation:** See `.cursor/rules/security-rules.mdc` for complete page permissions system including architecture, database tables, pattern matching, cache strategy, admin UI guide, and developer guidelines.

**Quick Reference:**

- **4-Tier Lookup**: Redis Cache → Database Override → Code Override → Convention Default
- **Access Levels**: `NONE` (redirect) | `VIEW` (read-only) | `FULL` (all actions)
- **Admin UI**: `/dashboard/admin/page-permissions` (SYSTEM_ADMIN only)
- **Convention Defaults**:
  - Admin pages: SYSTEM_ADMIN only
  - Analytics/BD: PARTNER+ (MANAGER gets VIEW)
  - Regular pages: All roles FULL, VIEWER gets VIEW

**Usage**:

```typescript
// Every page layout must use PageAccessGuard
<PageAccessGuard pathname={pathname}>{children}</PageAccessGuard>

// Check access level in components
const { isViewOnly, canEdit } = usePageAccess();
{isViewOnly && <ViewOnlyBadge />}
<EditActionWrapper><button>Edit</button></EditActionWrapper>

// Programmatic checks (server-side)
const { canAccess, accessLevel } = await checkPageAccess(userId, pathname);
```

**Implementation Files**:
- `@/lib/permissions/pageAccess.ts` - 4-tier lookup logic
- `@/lib/permissions/pagePermissions.ts` - Code-based permission matrix
- `@/components/guards/PageAccessGuard.tsx` - Server component guard
- `@/lib/services/admin/pagePermissionService.ts` - CRUD operations

### Frontend Security

- `<FeatureGate feature={Feature.X}>` for conditional UI
- `useFeature(Feature.X)` hook for checks
- Server Components default, `'use client'` only when needed

### User Interface & Interaction Patterns (CRITICAL)

**Browser Dialogs Are PROHIBITED:**
- ❌ NEVER use `confirm()` - unprofessional, no branding, poor UX
- ❌ NEVER use `alert()` - breaks user flow, cannot be styled
- ❌ NEVER use `prompt()` - inadequate validation, poor accessibility

**Instead, use custom modal components:**
- ✅ Confirmation modals for destructive actions (delete, archive, etc.)
- ✅ Banner components for success/error messages (NOT toast libraries)
- ✅ Inline validation for forms
- ✅ Modal dialogs with proper context and branding

**Implementation:**
```typescript
// ❌ WRONG: Browser dialog
if (!confirm('Delete this item?')) return;

// ✅ CORRECT: Custom modal
import { ConfirmModal } from '@/components/shared/ConfirmModal';
const [showConfirm, setShowConfirm] = useState(false);

<ConfirmModal
  isOpen={showConfirm}
  onClose={() => setShowConfirm(false)}
  onConfirm={handleDelete}
  title="Delete Client?"
  message={`Are you sure you want to delete "${clientName}"? This action cannot be undone.`}
  confirmText="Delete"
  variant="danger"
/>

// ❌ WRONG: Alert for errors
alert('Failed to save');

// ❌ WRONG: External toast libraries (sonner, react-toastify, etc.)
import { toast } from 'sonner';
toast.error('Failed to save');

// ✅ CORRECT: Banner component with state management
import { Banner } from '@/components/ui';
const [error, setError] = useState<string | null>(null);
const [success, setSuccess] = useState<string | null>(null);

// On error
setError('Failed to save changes. Please try again.');

// On success
setSuccess('Changes saved successfully');
setTimeout(() => setSuccess(null), 5000); // Auto-hide after 5s

// In JSX
{error && (
  <Banner 
    variant="error" 
    message={error}
    dismissible
    onDismiss={() => setError(null)}
  />
)}
{success && (
  <Banner 
    variant="success" 
    message={success}
    dismissible
    onDismiss={() => setSuccess(null)}
  />
)}
```

**See:** `.cursor/rules/forvis-design-rules.mdc` for modal component specifications

### Input Validation & Sanitization

- Validate route params + query strings via Zod or `parseXxxId()` (not just body)
- Zod schemas use `.strict()` for mutations (prevents mass assignment)
- User-controlled sorting/filtering must use allowlists (no raw field passthrough)
- List endpoints enforce limits (`take` with max value, validate cursor/skip)
- Explicit field mapping in Prisma `data` - never spread user input directly

### Authorization Beyond Roles

- **IDOR protection**: Verify user access to specific resources, not just role checks
- Filter out soft-deleted records where applicable
- Business logic authorization (e.g., users can't approve their own submissions)

### Data Protection

- `Cache-Control: no-store` for sensitive/user-specific responses
- Audit logging for sensitive operations (include userId, resourceId - no secrets/PII)
- File uploads: validate size + MIME type allowlist; storage paths not user-controlled
- `X-Content-Type-Options: nosniff` for file downloads
- **Blob Storage**: MUST use purpose-specific containers (see `.cursor/rules/blob-storage-rules.mdc`)

## Performance (REQUIRED)

### Imports

- **Static imports ONLY** at top of file - NO `await import()` in handlers
- Exception: AI/ML dependencies may use lazy loading for bundle size

### Database

- ALWAYS explicit `select:` fields
- Batch queries: `Promise.all()`
- Transactions (`prisma.$transaction`) for multi-step mutations
- Prevent N+1 queries
- Default limits on `findMany()` - no unbounded queries on large tables
- Deterministic ordering for pagination (cursor or stable `orderBy` with secondary sort)

### Request Handling

- Large payloads: paginate or stream responses
- External API calls: parallelize with `Promise.all()` + set timeouts
- Race conditions: use optimistic locking or transactions for concurrent mutations
- Response size: bound large JSON responses

### Caching

**TTLs:** Sessions 1h | User/Task 10min | Analytics/Static 30min

**Prefixes:** `CACHE_PREFIXES.SESSION`, `USER`, `TASK`, `SERVICE_LINE`, `ANALYTICS`

**Cache Invalidation (after mutations):**
```typescript
import { invalidateOnTaskMutation, invalidateOnClientMutation, invalidateApprovalsCache } from '@/lib/services/cache/cacheInvalidation';

await invalidateOnTaskMutation(taskId, serviceLine, subServiceLineGroup);
await invalidateOnClientMutation(clientId);
await invalidateApprovalsCache(); // After approval mutations
```

### Logging

```typescript
import { logger } from '@/lib/utils/logger';
logger.info('Action completed', { userId, taskId });
logger.warn('Unusual condition', { details });
logger.error('Operation failed', error);
// NEVER use console.log/warn/error in production code
```

## Error Handling

```typescript
throw new AppError(status, message, ErrorCodes.X, metadata);
return handleApiError(error, 'Context');
```

Codes: `VALIDATION_ERROR`, `NOT_FOUND`, `FORBIDDEN`, `UNAUTHORIZED`

## Data Integrity

- Validate foreign key references exist before insert/update
- Idempotency for critical mutations (retrying POST/PUT shouldn't create duplicates)
- Check unique constraints before insert to prevent race condition errors
- Timezone: store/return UTC, convert on frontend
- Decimal precision: use `Decimal.js` for financial data, never floats

## Approval System (REQUIRED)

**All approval workflows MUST use the centralized approval system** (see `.cursor/rules/approval-system-rules.mdc`):

```typescript
import { approvalService } from '@/lib/services/approvals/approvalService';

// Create approval when workflow needs approval
const approval = await approvalService.createApproval({
  workflowType: 'CHANGE_REQUEST', // or ACCEPTANCE, ENGAGEMENT_LETTER, etc.
  workflowId: item.id,
  title: 'Descriptive title',
  requestedById: user.id,
  context: { /* data for routing */ }
});

// Link back to workflow
await prisma.yourTable.update({
  where: { id: item.id },
  data: { approvalId: approval.id }
});
```

**Benefits:** Centralized logic, reusable workflows, multi-approver support, delegation, audit trail

## Code Quality

- Extract utilities for 3+ uses
- Files under 500 lines
- camelCase file names
- No duplicates, no deprecated code
- Business logic in `/src/lib/services/<domain>/`
- Components: `ui/`, `layout/`, `shared/`, `features/<domain>/`

## AI Assistant

- Upon task completion, simply state "Completed"
- No verbose summaries after finishing work

## Core Principles

Security checks are NOT optional. Performance patterns are REQUIRED. Type safety is MANDATORY.
