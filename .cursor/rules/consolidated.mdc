---
alwaysApply: true
version: 2.1.0
lastUpdated: 2026-01-23
changelog:
  - "2.1.0 (2026-01-23): Added migration-rules.mdc for Prisma + SQL Server best practices"
  - "2.0.0 (2026-01-21): Removed security duplication, streamlined with references to specialized files"
  - "1.0.0: Initial consolidated conventions"
---

# Project Conventions

Next.js 14 (App Router) | TypeScript (strict) | Prisma | React Query | Azure OpenAI | Azure AD

## Quick Reference Table

| Task | Rule/Pattern | See Section |
|------|--------------|-------------|
| Create API route | Use `secureRoute.mutation/query` | Security (CRITICAL) |
| Validate user input | Zod schemas + `parseXxxId()` | Security (CRITICAL) |
| Protect page | `<PageAccessGuard pathname={...}>` | Security > Page-Level Access |
| Check feature access | `<FeatureGate feature={...}>` | Security > Frontend Security |
| Query database | Use explicit `select:`, add `take` limits | Performance > Database |
| Work with employees/staff | Use Employee table (Active status), not User | Database > Data Model Relationships |
| Store files | Purpose-specific blob containers | See blob-storage-rules.mdc |
| Create approval flow | `approvalService.createApproval()` | See approval-system-rules.mdc |
| Use AI generation | Import from `@/lib/ai/config` | See ai-patterns.mdc |
| Show user messages | Banner component (NOT toast/alert) | See forvis-design-rules.mdc |
| Handle errors | `try/catch` + `logger.error()` + `AppError` | Error Handling |
| Invalidate cache | Call specific cache invalidation functions | Performance > Caching Strategy |
| Add new tool | Register in ToolRegistry + database | See tool-system-rules.mdc |
| Schema migration | Use `db push` for dev, `migrate dev` for production | See migration-rules.mdc |

## Specialized Rule Files (When To Consult)

**ALWAYS consult these files for their specific domains:**

### `.cursor/rules/forvis-design-rules.mdc` (CRITICAL)
**When:** Building ANY UI components, modals, forms, cards, or interactive elements
**Key Rules:** 
- NEVER use browser dialogs (`confirm()`, `alert()`, `prompt()`)
- Use `@/components/ui` imports for all UI components
- Follow gradient registry for backgrounds and styling
- Use Banner component (NOT toast libraries like sonner/react-toastify)

### `.cursor/rules/security-rules.mdc` (REQUIRED)
**When:** Creating API routes, implementing page permissions, or access control
**Key Rules:**
- ALL API routes MUST use `secureRoute` wrapper
- Use `<PageAccessGuard>` for page protection
- Use `<FeatureGate>` for conditional UI rendering
- Follow 4-tier permission lookup (Cache → DB → Code → Convention)

### `.cursor/rules/approval-system-rules.mdc`
**When:** Implementing ANY workflow requiring approval (acceptance, engagement letters, change requests, DPA, review notes)
**Key Rules:**
- Use centralized `approvalService.createApproval()`
- Register workflow type in `workflowRegistry.ts`
- ALWAYS call `invalidateApprovalsCache()` after mutations
- Use `UnifiedApprovalCard` for UI display

### `.cursor/rules/ai-patterns.mdc`
**When:** Using Azure OpenAI, document intelligence, RAG, or AI agents
**Key Rules:**
- Import models from `@/lib/ai/config`
- Use `secureRoute.ai()` for AI endpoints (strict rate limiting)
- Check `RAGEngine.isConfigured()` before use
- Follow service selection hierarchy (orchestrator → individual agents → RAG → direct SDK)

### `.cursor/rules/blob-storage-rules.mdc`
**When:** Uploading files to Azure Blob Storage or creating new document storage features
**Key Rules:**
- MUST use purpose-specific containers (never mix document types)
- Follow naming: `{purpose}` or `{purpose}-{category}`
- Path structure: `{entityId}/{timestamp}_{sanitized_filename}`
- Create dedicated container client for each document type

### `.cursor/rules/tool-system-rules.mdc`
**When:** Creating tools, working with junction tables, or tool-task relationships
**Key Rules:**
- All Prisma relations MUST use PascalCase matching model names
- Junction tables: `[Entity1][Entity2]` naming pattern
- User relations: Use descriptive names `User_[Model]_[field]ToUser`
- Tools integrate with approval system for items requiring approval

### `.cursor/rules/migration-rules.mdc` (REQUIRED)
**When:** Making schema changes, running migrations, or troubleshooting database issues
**Key Rules:**
- Use `prisma db push` for development iteration (fast, no shadow DB)
- Use `prisma migrate dev` for production-bound changes (creates migration files)
- Large table migrations (>500K rows) MUST be applied manually to avoid timeouts
- Always run `prisma migrate status` before deployments
- NEVER use `mode: 'insensitive'` in Prisma queries (not supported by SQL Server)
- Document manual migrations with README in migration folder

## TypeScript

**Type Organization:** Prisma Schema -> `types/index.ts` -> derive DTOs with Partial/Pick/Omit
- `types/branded.ts`: Branded ID types | `types/dto.ts`: DTOs | `types/api.ts`: API types

**Requirements:**
- Strict mode, `@/*` imports, ALL IDs use branded types
- Route params via `parseXxxId()` utilities
- Define enums ONCE in `types/index.ts` (e.g., `SystemRole`, `ServiceLineRole`)
- `undefined` for optional, `null` for database nulls
- **NO `any` types** - Use `unknown`, `Record<string, unknown>`, or proper interfaces
- All input validated via Zod schemas in `/src/lib/validation/schemas.ts`

## Database

**Dual-ID Convention:**
- **Internal IDs** (`id`): Auto-increment PKs for internal-only tables (TaskTeam, BDOpportunity)
- **External IDs** (`GS*`): GUIDs for external system tables (Client, Task, Employee, Wip)
- **Codes** (`*Code`): Display/search ONLY, NEVER for relationships

**Query Patterns:**
```typescript
// External tables: use GS* for relationships
const tasks = await prisma.task.findMany({ where: { GSClientID: client.GSClientID } });

// Internal tables: use id
const team = await prisma.taskTeam.findMany({ where: { taskId: task.id } });

// Codes: search only
const clients = await prisma.client.findMany({ where: { clientCode: { contains: term } } });
```

**SQL Server Case Sensitivity:**
- **NEVER use `mode: 'insensitive'`** - not supported by SQL Server (PostgreSQL/MySQL only)
- SQL Server uses collation-based case sensitivity (default: `SQL_Latin1_General_CP1_CI_AS` is case-insensitive)
- Use `contains`, `startsWith`, `endsWith` without mode parameter for case-insensitive searches

**Data Model Relationships (CRITICAL):**
- **Clients are unique to Groups**: Each client belongs to exactly one group (`groupCode`). When creating/updating APIs that work with clients, always validate that the client belongs to the specified group.
- **Tasks are unique to Clients**: Each task belongs to exactly one client (`GSClientID`). When creating/updating APIs that work with tasks, always validate that the task belongs to the specified client.
- **Employees vs Users (CRITICAL)**: Employee table is the source of truth for all staff functionality. User table is for Azure AD authentication only. Employee functionality is governed by `Active = 'Yes'`, regardless of whether employee has a User account. Employee.WinLogon (optional) links to User for system access confirmation.

```typescript
// Example: Validate task belongs to client in API
const task = await prisma.task.findUnique({
  where: { id: taskId },
  select: { GSClientID: true }
});
if (task?.GSClientID !== clientId) {
  throw new AppError(404, 'Task not found', ErrorCodes.NOT_FOUND);
}

// Example: Validate client belongs to group in API
const client = await prisma.client.findUnique({
  where: { GSClientID: clientId },
  select: { groupCode: true }
});
if (client?.groupCode !== groupCode) {
  throw new AppError(404, 'Client not found', ErrorCodes.NOT_FOUND);
}

// Example: Query active employees (includes those without User accounts)
const staff = await prisma.employee.findMany({
  where: { Active: 'Yes', ServLineCode: serviceLineCode }
});

// INCORRECT: Filtering out employees without accounts
const staff = await prisma.employee.findMany({
  where: { Active: 'Yes', WinLogon: { not: null } } // ❌ Excludes active employees
});
```

**Fiscal Period Filtering (REQUIRED):**
- **Fiscal Year:** September to August (FY2024 = Sep 2023 - Aug 2024)
- **ALWAYS use fiscal period helpers** from `@/lib/services/reports/fiscalPeriodQueries` for date filtering
- **NEVER manually calculate** fiscal periods - use provided utilities
- **Available on transaction tables:** `WIPTransactions`, `DrsTransactions`, `Wip`, `Debtors`, `WIPAging`

```typescript
import { buildFiscalPeriodFilter, getFiscalPeriods } from '@/lib/services/reports/fiscalPeriodQueries';
import { getFiscalYear, formatFiscalPeriod } from '@/lib/utils/fiscalPeriod';

// Server-side: Filter transactions by fiscal period
const where = buildFiscalPeriodFilter(
  { fiscalYear: 2024, fiscalQuarter: 2 },
  'TranDate' // date field name
);
const transactions = await prisma.wIPTransactions.findMany({ where });

// Client-side: Get fiscal year from date
const fiscalYear = getFiscalYear(new Date()); // Returns 2024

// Get available fiscal periods for dropdowns
const years = await getFiscalPeriods({ groupBy: 'year' });
const quarters = await getFiscalPeriods({ fiscalYear: 2024, groupBy: 'quarter' });
```

**SQL Functions Available:**
- `dbo.GetFiscalYear(date)` - Returns fiscal year (e.g., 2024)
- `dbo.GetFiscalQuarter(date)` - Returns quarter 1-4
- `dbo.GetFiscalMonth(date)` - Returns fiscal month 1-12 (1=Sep, 12=Aug)
- `dbo.GetFiscalPeriodKey(date)` - Returns period key for joins

**Documentation:** See `docs/FISCAL_PERIOD_USAGE.md` for complete guide

## Service Lines

**Client-Facing:** TAX, AUDIT, ACCOUNTING, ADVISORY
**Shared Services:** QRM, BUSINESS_DEV, IT, FINANCE, HR, COUNTRY_MANAGEMENT

**Tables:**
- `ServiceLineMaster`: Application master list (code, name, active)
- `ServiceLineExternal`: Maps `ServLineCode` -> `SubServlineGroupCode` -> `masterCode`
- `ServiceLineUser`: User assignments to `subServiceLineGroup` with `role`

**Access Pattern:** Task's `ServLineCode` -> `SubServlineGroupCode` -> check user's `ServiceLineUser` assignments

**URL:** `/dashboard/[serviceLine]/[subServiceLineGroup]/clients/[id]/tasks/[taskId]`

## Security (CRITICAL)

### Role Model

1. **System**: `SYSTEM_ADMIN` > `USER`
2. **Service Line**: `ADMINISTRATOR` > `PARTNER` > `MANAGER` > `SUPERVISOR` > `USER` > `VIEWER`

Roles defined in `@/lib/utils/roleHierarchy.ts`. SYSTEM_ADMIN bypasses all checks.

### API Routes - Use secureRoute (REQUIRED)

All API routes MUST use the `secureRoute` wrapper. See `.cursor/rules/security-rules.mdc` for complete documentation.

**Quick Reference:**
```typescript
import { secureRoute, Feature } from '@/lib/api/secureRoute';

// Mutations: secureRoute.mutation({ feature, schema, handler })
// Queries: secureRoute.query({ feature, handler })
// With params: secureRoute.queryWithParams({ taskIdParam: 'id', handler })
// AI endpoints: secureRoute.ai({ schema, handler })
// File uploads: secureRoute.fileUpload({ handler })
```

**secureRoute handles:** Authentication, rate limiting, input sanitization, Zod validation, error handling, performance tracking

**Your responsibility:** Choose correct wrapper, specify feature, use explicit `select:`, call cache invalidation, use `logger`

### Page-Level Access

See `.cursor/rules/security-rules.mdc` for complete page permissions system (4-tier lookup, admin UI, implementation guide).

**Quick Usage:**
```typescript
// Every page layout must use PageAccessGuard
<PageAccessGuard pathname={pathname}>{children}</PageAccessGuard>

// Check access level in components
const { isViewOnly, canEdit } = usePageAccess();
```

### Frontend Security

- `<FeatureGate feature={Feature.X}>` for conditional UI
- `useFeature(Feature.X)` hook for checks
- Server Components default, `'use client'` only when needed

### User Interface & Interaction Patterns

**CRITICAL:** Browser dialogs (`confirm()`, `alert()`, `prompt()`) are PROHIBITED.

See `.cursor/rules/forvis-design-rules.mdc` for:
- Confirmation modal patterns
- Banner component usage
- Inline validation
- Modal specifications

### Input Validation, Authorization & Data Protection

See `.cursor/rules/security-rules.mdc` for complete security guidelines including:
- Input validation and sanitization patterns
- IDOR protection strategies
- Authorization beyond roles
- Data protection and audit logging

**Key Points:**
- Validate ALL inputs (params, query, body) via Zod or `parseXxxId()`
- Use `.strict()` on Zod schemas for mutations
- IDOR protection: verify user access to specific resources
- Blob Storage: use purpose-specific containers (see `.cursor/rules/blob-storage-rules.mdc`)

## Post-Edit Validation (REQUIRED)

After changing or adding files, verify:

### API Routes (src/app/api/**/route.ts)
- ✅ Uses `secureRoute` wrapper (query/mutation/ai/fileUpload)
- ✅ *WithParams variant for routes with [id] segments
- ✅ Feature permission specified
- ✅ Schema validation for mutations (POST/PUT/PATCH/DELETE)
- ✅ Route params validated with `parseXxxId()` utilities
- ✅ IDOR protection (user can only access their resources)
- ✅ Explicit `select:` fields in Prisma queries
- ✅ Cache invalidation after mutations
- ✅ No `console.log` - use `logger` instead
- ✅ No manual `sanitizeText()` calls (automatic in secureRoute)
- ✅ List endpoints have `take` limits

### Components (src/components/**/*)
- ✅ No browser dialogs (`confirm()`, `alert()`, `prompt()`)
- ✅ Use Banner component for messages (not toast libraries)
- ✅ Use `@/components/ui` imports for UI elements
- ✅ `<FeatureGate>` for conditional access
- ✅ `'use client'` only when needed

### Database Queries (All Files)
- ✅ Explicit `select:` - never select all fields
- ✅ `take` limits on `findMany()` for large tables
- ✅ No N+1 queries - use `include` or batch with `Promise.all()`
- ✅ Transactions for multi-step mutations

### All Files
- ✅ No `any` types - use `unknown` or proper interfaces
- ✅ Branded IDs used correctly (TaskId, ClientId, etc.)
- ✅ No `console.log/warn/error` - use `logger`
- ✅ Static imports only (no `await import()` except AI/ML)
- ✅ Correct import paths (no stale imports)

**Full Route Review:** See `/ROUTE_REVIEW_INDEX.md` for route review dashboard. Detailed review standards in `/docs/ROUTE_REVIEW_STANDARDS.md`. Domain-specific reviews in `/docs/route-reviews/*.md`.

## Performance (REQUIRED)

### Imports

- **Static imports ONLY** at top of file - NO `await import()` in handlers
- Exception: AI/ML dependencies may use lazy loading for bundle size

### Database

- ALWAYS explicit `select:` fields
- Batch queries: `Promise.all()`
- Transactions (`prisma.$transaction`) for multi-step mutations
- Prevent N+1 queries
- Default limits on `findMany()` - no unbounded queries on large tables
- Deterministic ordering for pagination (cursor or stable `orderBy` with secondary sort)

### Request Handling

- Large payloads: paginate or stream responses
- External API calls: parallelize with `Promise.all()` + set timeouts
- Race conditions: use optimistic locking or transactions for concurrent mutations
- Response size: bound large JSON responses

### Caching Strategy

**Hybrid Approach:** React Query (client-side) + Redis (server-side)

**React Query (Client-Side):**
- Entity details (tasks, clients, groups, employees)
- List data with pagination
- Automatic invalidation on mutations
- Cache keys: `['tasks', taskId]`, `['clients', clientId]`

**Redis/Memory Cache (Server-Side):**
- **Sessions** (1h) - User authentication sessions
- **Permissions** (10min) - User feature/role permissions
- **Rate Limiting** (varies) - Per-user and per-IP rate limits
- **Analytics** (30min) - Workspace counts, graphs, aggregations
- **Planner Data** (5-30min) - Staff planner queries (expensive joins)
- **Service Lines** (10min) - Service line mappings and metadata
- **Client Acceptance** (10min) - Server-side validation data
- **Document Vault** (10min) - Vault metadata
- **Employee Lookups** (10min) - Employee data for relationships

**When to Use Which:**
- **React Query:** Entity CRUD, lists, user-specific data
- **Redis:** Shared state, expensive aggregations, rate limiting, sessions

**Cache Invalidation (after mutations):**
```typescript
import { invalidateApprovalsCache, invalidateWorkspaceCounts, invalidatePlannerCachesForServiceLine } from '@/lib/services/cache/cacheInvalidation';

// After approval mutations
await invalidateApprovalsCache();

// After task/client mutations affecting counts
await invalidateWorkspaceCounts(serviceLine, subServiceLineGroup);

// After task team mutations (invalidates planner)
await invalidatePlannerCachesForServiceLine(serviceLine, subServiceLineGroup);

// React Query invalidation (client-side)
queryClient.invalidateQueries({ queryKey: ['tasks', taskId] });
queryClient.invalidateQueries({ queryKey: ['clients', clientId] });
```

**List Caching:** Only first 3 pages cached (5min TTL), searches skipped.

**Performance:** Uses SCAN (not KEYS) for pattern invalidation, silent failure on cache errors.

### Logging

```typescript
import { logger } from '@/lib/utils/logger';
logger.info('Action completed', { userId, taskId });
logger.warn('Unusual condition', { details });
logger.error('Operation failed', error);
// NEVER use console.log/warn/error in production code
```

## Error Handling

```typescript
throw new AppError(status, message, ErrorCodes.X, metadata);
return handleApiError(error, 'Context');
```

Codes: `VALIDATION_ERROR`, `NOT_FOUND`, `FORBIDDEN`, `UNAUTHORIZED`

## Data Integrity

- Validate foreign key references exist before insert/update
- Idempotency for critical mutations (retrying POST/PUT shouldn't create duplicates)
- Check unique constraints before insert to prevent race condition errors
- Timezone: store/return UTC, convert on frontend
- Decimal precision: use `Decimal.js` for financial data, never floats

## Approval System (REQUIRED)

**All approval workflows MUST use the centralized approval system** (see `.cursor/rules/approval-system-rules.mdc`):

```typescript
import { approvalService } from '@/lib/services/approvals/approvalService';

// Create approval when workflow needs approval
const approval = await approvalService.createApproval({
  workflowType: 'CHANGE_REQUEST', // or ACCEPTANCE, ENGAGEMENT_LETTER, etc.
  workflowId: item.id,
  title: 'Descriptive title',
  requestedById: user.id,
  context: { /* data for routing */ }
});

// Link back to workflow
await prisma.yourTable.update({
  where: { id: item.id },
  data: { approvalId: approval.id }
});
```

**Benefits:** Centralized logic, reusable workflows, multi-approver support, delegation, audit trail

## Code Quality

**Directory Structure:**
- API Routes: `/src/app/api/<domain>/` (clients/, tasks/, admin/)
- Services: `/src/lib/services/<domain>/` (clients/, tasks/, templates/)
- Components: `ui/`, `layout/`, `shared/`, `features/<domain>/`
- Hooks: `/src/hooks/<domain>/` (tasks/, clients/, templates/, approvals/)
- Types: `/src/types/` (flat structure, domain-specific files)
- Utils: `/src/lib/utils/` (flat structure, single-purpose utilities)
- Constants: `/src/constants/` (flat structure)
- Tools: `/src/lib/tools/<tool-name>/` (complex tools with api/, services/, types/ subdirs)

**File Standards:**
- Extract utilities for 3+ uses
- Files under 500 lines
- camelCase file names
- No duplicates, no deprecated code

## AI Assistant

- Upon task completion, simply state "Completed"
- No verbose summaries after finishing work

## Core Principles

Security checks are NOT optional. Performance patterns are REQUIRED. Type safety is MANDATORY.


