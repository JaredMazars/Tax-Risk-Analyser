---
alwaysApply: true
---

# Project Conventions

Next.js 14 (App Router) | TypeScript (strict) | Prisma | React Query | Azure OpenAI | Azure AD

## TypeScript

**Strict mode enabled**: No implicit any, check nulls/undefined, handle array access, return from all paths

**Path aliases**: Always use `@/*` imports
```typescript
import { prisma } from '@/lib/db/prisma';
import { ProjectCard } from '@/components/features/projects/ProjectCard';
```

**Branded types** (`@/types/branded.ts`): Prevent ID type mixing
```typescript
import { toProjectId, ProjectId } from '@/types/branded';
const projectId = toProjectId(params.id); // Validates and brands
```

## Validation

**All input validated with Zod** (schemas in `/src/lib/validation/schemas.ts`):
```typescript
import { CreateProjectSchema } from '@/lib/validation/schemas';
const validated = CreateProjectSchema.parse(body); // Throws if invalid
```

## API Routes

### Standard Pattern
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getCurrentUser } from '@/lib/services/auth/auth';
import { successResponse } from '@/lib/utils/apiUtils';
import { handleApiError } from '@/lib/utils/errorHandler';

export async function GET(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    
    const data = await prisma.resource.findMany({ where: { userId: user.id } });
    return NextResponse.json(successResponse(data));
  } catch (error) {
    return handleApiError(error, 'GET /api/resource');
  }
}

export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    
    const body = await request.json();
    const validated = Schema.parse(body);
    
    const resource = await prisma.resource.create({
      data: { ...validated, userId: user.id }
    });
    
    return NextResponse.json(successResponse(resource), { status: 201 });
  } catch (error) {
    return handleApiError(error, 'POST /api/resource');
  }
}
```

### Dynamic Routes
```typescript
export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  const user = await getCurrentUser();
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  
  const { id } = await context.params; // Always await params
  const resourceId = toResourceId(id);
  
  const hasAccess = await checkAccess(user.id, resourceId);
  if (!hasAccess) return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  
  const resource = await prisma.resource.findUnique({ where: { id: resourceId } });
  if (!resource) return NextResponse.json({ error: 'Not found' }, { status: 404 });
  
  return NextResponse.json(successResponse(resource));
}
```

### Authentication
Manual check in each route (preferred):
```typescript
const user = await getCurrentUser();
if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
```

Optional middleware (`@/lib/api/middleware`):
```typescript
import { withAuth, withProjectAccess } from '@/lib/api/middleware';
export const GET = withAuth(async (request, { user }) => { ... });
```

### Authorization
```typescript
import { checkProjectAccess } from '@/lib/services/auth/auth';
const hasAccess = await checkProjectAccess(user.id, projectId, 'ADMIN'); // Optional role
```

### Request/Response
```typescript
// Parse body
const body = await request.json();
const formData = await request.formData();

// Query params
const { searchParams } = new URL(request.url);
const filter = searchParams.get('filter');

// Success response format
{ success: true, data: {...} }

// Error response format
{ success: false, error: "Message", code: "ERROR_CODE" }
```

### Status Codes
200 (GET/PUT/DELETE), 201 (POST), 400 (validation), 401 (unauthorized), 403 (forbidden), 404 (not found), 409 (conflict), 500 (server error)

## Database (Prisma)

**Singleton**: `import { prisma } from '@/lib/db/prisma'`

```typescript
// Query
const items = await prisma.resource.findMany({
  where: { userId },
  select: { id: true, name: true }, // Select only needed fields
  include: { relation: true }
});

// Create
await prisma.resource.create({ data: {...} });

// Update
await prisma.resource.update({ where: { id }, data: {...} });

// Delete
await prisma.resource.delete({ where: { id } });

// Transactions
await prisma.$transaction(async (tx) => {
  await tx.resource.update({...});
  await tx.auditLog.create({...});
});
```

## Error Handling

```typescript
import { AppError, ErrorCodes } from '@/lib/utils/errorHandler';

// Throw structured error
throw new AppError(404, 'Not found', ErrorCodes.NOT_FOUND, { id });

// API routes - always use handleApiError in catch
catch (error) {
  return handleApiError(error, 'GET /api/resource');
}
```

## Services

Business logic in `/src/lib/services/<domain>/`. Pure functions or classes, no request/response handling.

```typescript
// services/documents/blobStorage.ts
export async function uploadToBlob(buffer: Buffer, fileName: string): Promise<string> {
  // Implementation
}

// services/opinions/ragEngine.ts
export class RAGEngine {
  async search(query: string) { ... }
}
```

## Components

### Organization
```
components/
├── features/       # Feature-specific (domain-grouped)
│   ├── clients/
│   ├── projects/
│   ├── opinions/
│   └── tax-adjustments/
├── shared/         # Reusable across features
├── layout/         # Nav, headers, sidebars
└── ui/             # Base components (shadcn/ui)
```

**Decision tree**:
- Base UI (button, input)? → `ui/`
- Layout structure? → `layout/`
- Used by 2+ features? → `shared/`
- Feature-specific? → `features/<domain>/`

### Component Patterns
```typescript
// Use named exports (avoid default)
export function ComponentName({ prop }: Props) {
  // Client component if uses hooks/events
  // Add 'use client' directive at top
}

export interface Props { ... } // Export if reusable
```

### Server vs Client
Default: Server Components

Use `'use client'` when:
- Uses React hooks (useState, useEffect, etc.)
- Handles browser events (onClick, onChange)
- Uses React Query hooks

## State Management

**React Query** for server state:
```typescript
// hooks/<domain>/useResource.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

export function useResource(id: number) {
  return useQuery({
    queryKey: ['resource', id],
    queryFn: async () => {
      const res = await fetch(`/api/resource/${id}`);
      if (!res.ok) throw new Error('Failed');
      return res.json();
    },
  });
}

export function useCreateResource() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (data) => {
      const res = await fetch('/api/resource', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
      if (!res.ok) throw new Error('Failed');
      return res.json();
    },
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['resource'] }),
  });
}
```

**useState** for: form state, UI state (modals, toggles), component-specific temporary state

## Logging

```typescript
import { logger } from '@/lib/utils/logger';
logger.info('Event', { context, data });
logger.error('Error', { error: error.message, context });
logger.warn('Warning', { context });
```

Don't log secrets/PII. Use structured objects for context.

## Directory Structure

```
src/
├── app/                    # Next.js pages & API routes
│   ├── page.tsx
│   ├── layout.tsx
│   ├── auth/              # Auth pages
│   ├── dashboard/         # Main app
│   │   ├── clients/
│   │   ├── projects/[id]/
│   │   └── admin/
│   └── api/               # API routes (RESTful)
│       ├── auth/
│       ├── clients/
│       ├── projects/
│       └── users/
├── components/
│   ├── features/          # Domain-specific
│   ├── shared/            # Cross-feature reusable
│   ├── layout/            # Nav, headers
│   └── ui/                # Base components
├── lib/
│   ├── agents/            # AI orchestration
│   ├── ai/                # Azure OpenAI config
│   ├── api/               # API utilities
│   ├── auth.ts            # Auth core (MSAL, JWT)
│   ├── config/            # Env, React Query config
│   ├── db/                # Prisma singleton
│   ├── services/          # Business logic
│   │   ├── auth/
│   │   ├── documents/
│   │   ├── export/
│   │   ├── opinions/
│   │   └── tax/
│   ├── utils/             # Helpers
│   └── validation/        # Zod schemas
├── types/                 # TypeScript types
│   ├── branded.ts
│   ├── api.ts
│   └── dto.ts
├── constants/             # App constants
├── hooks/                 # React hooks
└── middleware.ts          # Next.js middleware

prisma/
├── schema.prisma
└── migrations/
```

## Best Practices

**API Routes**:
- Always authenticate manually in each route
- Validate all input with Zod
- Use `successResponse` and `handleApiError`
- Await `context.params` in dynamic routes
- Use branded types for IDs
- Select only needed DB fields
- Use transactions for multi-step operations

**Components**:
- Use `@/` imports
- Named exports over default
- Start with Server Components, add `'use client'` only when needed
- Co-locate feature-specific hooks
- Extract to `shared/` when used by 2+ features

**TypeScript**:
- Strict mode - no implicit any
- Check undefined/null before access
- Use branded types for IDs
- Type all function parameters and return values
- Always check the build when you make a change and correct errors
- The build should be vissible

**Security**:
- Validate all input
- Check authentication in every protected route
- Verify authorization for resource access
- Never expose secrets in client code
- Use Prisma (parameterized queries)

**Performance**:
- React Query for caching
- Select specific DB fields
- Use DB indexes for frequent queries
- Implement pagination for large datasets
- Server Components by default
