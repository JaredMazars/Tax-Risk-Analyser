---
alwaysApply: true
---

# Project Conventions

Next.js 14 (App Router) | TypeScript (strict) | Prisma | React Query | Azure OpenAI | Azure AD

## Styling

See `.cursor/rules/forvis-design-rules.mdc`

## AI

See `.cursor/rules/ai-patterns.mdc`

## TypeScript

**Type Organization:**
- Prisma Schema → `types/index.ts` → derive DTOs with Partial/Pick/Omit
- `types/branded.ts`: Branded ID types only
- `types/dto.ts`: Data transfer objects
- `types/api.ts`: API-specific types

**Requirements:**
- Strict mode, `@/*` imports
- ALL IDs use branded types
- Route params converted via `parseXxxId()` utilities
- NO duplicate types, NO deprecated code
- Define enums ONCE in types/index.ts
- `undefined` for optional, `null` for database nulls
- Optional chaining (`?.`) and nullish coalescing (`??`)

**Validation:** All input via Zod schemas in `/src/lib/validation/schemas.ts`

## Database

**Dual-ID Convention:**
- **Internal IDs** (`id`): Auto-increment integer primary keys for ALL tables
- **External IDs** (`GS*` prefix): UniqueIdentifier (GUID) fields from the external database system
- **Codes** (`*Code` suffix): String fields ONLY for display and search, NEVER for relationships

**Examples:**
- `Client` table: `id` (internal) vs `GSClientID` (external GUID) vs `clientCode` (display/search)
- `Task` table: `id` (internal) vs `GSTaskID` (external GUID) vs `TaskCode` (display/search)
- `Employee` table: `id` (internal) vs `GSEmployeeID` (external GUID) vs `EmpCode` (display/search)

**Usage:**
- Tables that sync with external systems (Client, Task, Employee, Wip, Debtors) use `GS*` GUIDs for relationships with each other
- Internal-only tables (TaskTeam, TaskDocument, BDOpportunity, etc.) use `id` integer fields for relationships
- Use `*Code` fields ONLY for display and search operations, NEVER for relationships
- Route parameters and API responses continue using internal `id` for application routing

**Schema Patterns:**

**External System Tables** (use GS* for relationships with each other):
```prisma
model Client {
  id         Int      @id @default(autoincrement())  // Internal ID - for internal-only relations
  clientCode String   @unique                         // For display/search ONLY
  GSClientID String   @unique @db.UniqueIdentifier   // External ID - for external table relations
  Task       Task[]   // Relation uses GSClientID
}

model Task {
  id         Int      @id @default(autoincrement())  // Internal ID - for internal-only relations
  GSTaskID   String   @unique @db.UniqueIdentifier   // External ID - for external table relations
  GSClientID String?  @db.UniqueIdentifier           // External FK - for queries with Client
  TaskCode   String                                   // Display/search ONLY
  Client     Client?  @relation(fields: [GSClientID], references: [GSClientID])
}

model Wip {
  id         Int      @id @default(autoincrement())  // Internal ID
  GSWipID    String   @unique @db.UniqueIdentifier   // External ID
  GSClientID String   @db.UniqueIdentifier           // External FK - for queries with Client
  GSTaskID   String   @db.UniqueIdentifier           // External FK - for queries with Task
  Client     Client?  @relation(fields: [GSClientID], references: [GSClientID])
  Task       Task?    @relation(fields: [GSTaskID], references: [GSTaskID])
}
```

**Internal-Only Tables** (use id for relationships):
```prisma
model TaskTeam {
  id     Int    @id @default(autoincrement())
  taskId Int                                    // Internal FK - uses id
  userId String
  Task   Task   @relation(fields: [taskId], references: [id])
  User   User   @relation(fields: [userId], references: [id])
}

model BDOpportunity {
  id       Int     @id @default(autoincrement())
  clientId Int?                                 // Internal FK - uses id
  Client   Client? @relation(fields: [clientId], references: [id])
}
```

**Query Patterns:**

✅ **CORRECT** - Use GS* for external table relationships:
```typescript
// DO use external GUID for queries between synced tables
const tasks = await prisma.task.findMany({
  where: { GSClientID: client.GSClientID }
});

const wip = await prisma.wip.findMany({
  where: { GSTaskID: task.GSTaskID }
});
```

✅ **CORRECT** - Use id for internal table relationships:
```typescript
// DO use internal ID for internal-only tables
const teamMembers = await prisma.taskTeam.findMany({
  where: { taskId: task.id }
});

const opportunities = await prisma.bDOpportunity.findMany({
  where: { clientId: client.id }
});
```

❌ **WRONG** - Using Code for relationships:
```typescript
// DON'T use codes for foreign keys
const tasks = await prisma.task.findMany({
  where: { ClientCode: clientCode }
});
```

✅ **CORRECT** - Codes only for search:
```typescript
// Codes ONLY for search
const clients = await prisma.client.findMany({
  where: { clientCode: { contains: searchTerm } }
});
```

## Service Lines & Shared Services

**Service Lines** (Client-facing, billable work):
- `TAX` - Tax services
- `AUDIT` - Audit services
- `ACCOUNTING` - Accounting services
- `ADVISORY` - Advisory services

**Shared Services** (Internal support functions):
- `QRM` - Quality & Risk Management
- `BUSINESS_DEV` - Business Development
- `IT` - Information Technology
- `FINANCE` - Internal Finance
- `HR` - Human Resources

**Defined in:** `types/index.ts` → `ServiceLine` enum (single source of truth)

**Utility:** `isSharedService()` in `@/lib/utils/serviceLineUtils.ts` distinguishes between client-facing and shared services

### Database Tables

| Table | Purpose |
|-------|---------|
| `ServiceLineMaster` | Application-level master list (seeded) - `code`, `name`, `description`, `active`, `sortOrder` |
| `ServiceLineExternal` | External system sync - maps `ServLineCode` → `masterCode` and `SubServlineGroupCode` |
| `ServiceLineUser` | User assignments - links users to `subServiceLineGroup` with `role` |

### SubServiceLineGroup Mapping

`ServiceLineExternal` bridges external system codes to application service lines:

```
ServLineCode → SubServlineGroupCode → masterCode (ServiceLineMaster.code)
```

- **Task.ServLineCode**: External service line code on tasks
- **ServiceLineExternal.SubServlineGroupCode**: Groups external codes into sub-service line groupings
- **ServiceLineExternal.masterCode**: Links to `ServiceLineMaster.code` for application routing
- **ServiceLineUser.subServiceLineGroup**: User access is granted at the `SubServlineGroupCode` level

**Query Pattern:** Map task's `ServLineCode` → find matching `SubServlineGroupCode` → check user's `ServiceLineUser` assignments

## URL Structure

`/dashboard/[serviceLine]/[subServiceLineGroup]/clients/[id]/tasks/[taskId]`

- `serviceLine`: TAX, AUDIT, ACCOUNTING, ADVISORY (or shared services: QRM, BUSINESS_DEV, IT, FINANCE, HR)
- `subServiceLineGroup`: Dynamic grouping from `ServiceLineExternal.SubServlineGroupCode`
- `id`: Internal client ID (integer, from Client.id)
- `taskId`: Internal task ID (integer, from Task.id)
- Even if the user refers to projects they actually mean tasks
- The applications centres around clients and tasks

**Note**: URLs use internal `id` fields for application routing. External `GS*` IDs are used for relationships between externally-synced tables (Client↔Task, Task↔Wip, etc.).


## Security (CRITICAL - NOT Optional)

### Three-Tier Model
1. **System**: `SYSTEM_ADMIN` > `USER`
2. **Service Line**: `ADMINISTRATOR` > `PARTNER` > `MANAGER` > `SUPERVISOR` > `USER` > `VIEWER`
3. **Task**: `ADMIN` > `REVIEWER` > `EDITOR` > `VIEWER`

### Feature-Based Permissions (TypeScript, No Database)

Instead of CRUD permissions, use **Feature Flags** defined in `@/lib/permissions/features.ts`:
- **Core Access**: `access_dashboard`, `access_clients`, `access_tasks`, `access_analytics`, `access_bd`, `access_admin`
- **Task Management**: `manage_tasks`, `assign_task_team`, `approve_acceptance`, `approve_engagement_letter`
- **Client Management**: `manage_clients`, `view_client_analytics`, `export_client_data`
- **Documents**: `upload_documents`, `download_documents`, `delete_documents`
- **Business Development**: `manage_opportunities`, `manage_contacts`, `view_bd_analytics`
- **Admin**: `manage_users`, `manage_service_lines`, `manage_templates`
- **Advanced**: `use_ai_tools`, `export_reports`, `view_wip_data`

Features are mapped to roles in `@/lib/permissions/featurePermissions.ts` (in-memory, no DB queries).

### API Route Pattern (REQUIRED - 6 Steps)

1. **Authenticate**: `getCurrentUser()` → return 401 if none
2. **Parse IDs**: Use `parseXxxId()` for branded types
3. **Check Feature**: `checkFeature(userId, Feature.X, serviceLine?)` → return 403 if denied
4. **Filter Service Lines**: `getUserServiceLines()` → filter accessible service lines
5. **Execute**: Query with `select:` (explicit fields only), filter by service lines
6. **Respond**: `successResponse(data)` or `handleApiError(error, context)`

**POST/PUT/PATCH:** Add `sanitizeObject()` + Zod validation after step 2

### Backend Security Checklist

- [ ] `getCurrentUser()` at start
- [ ] `checkFeature(userId, Feature.X)` before business logic
- [ ] Filter by `getUserServiceLines()` accessible service lines
- [ ] For tasks: `checkTaskAccess(userId, taskId, role?)`
- [ ] For approvals: `canApproveAcceptance()` or `canApproveEngagementLetter()`
- [ ] Return 401/403/404 appropriately
- [ ] `handleApiError()` in catch blocks
- [ ] Explicit `select:` fields only
- [ ] Transactions for multi-step operations
- [ ] Verify task team membership (TaskTeam table)

### Frontend Security

- Wrap UI: `<FeatureGate feature={Feature.X}>`
- Conditional: `useFeature(Feature.X, serviceLine?)`
- Server Components default, `'use client'` only when needed
- Never browser popups (use custom modals)

### UI Confirmations

- NEVER use `confirm()`, `alert()`, or `prompt()` browser dialogs
- ALWAYS use custom modal components for confirmations/alerts
- Destructive actions (delete, remove, etc.) require modal confirmation
- Modal should show action context (e.g., item name being deleted)

### Authorization Utilities

**Feature Checks** (`@/lib/permissions/checkFeature`):
- `checkFeature(userId, feature, serviceLine?)`: Check if user has feature
- `checkAnyFeature(userId, features[])`: Check if user has any of the features
- `checkAllFeatures(userId, features[])`: Check if user has all features
- `getUserFeatures(userId, serviceLine?)`: Get all features user has access to

**Task Access** (`@/lib/services/tasks/taskAuthorization`):
- `checkTaskAccess(userId, taskId, role?)`: Check team membership + role
- `getTaskRole(userId, taskId)`: Get user's task role
- `canModifyTask(userId, taskId)`: Check ADMIN/EDITOR
- `canApproveTask(userId, taskId)`: Check approval permission

**Auth** (`@/lib/services/auth/authorization`):
- `isSystemAdmin(userId)`, `getUserSystemRole()`, `getServiceLineRole()`
- `isPartner()`, `isManager()`, `hasServiceLineAccess()`
- `canApproveEngagementLetter()`, `canApproveAcceptance()`
- `hasFeature(userId, feature, serviceLine?)`: Convenience wrapper
- `canManageTasks()`, `canManageClients()`, `canAccessAdmin()`, etc.

### Security Principles

1. Defense in Depth: Check at system, service line, AND task levels
2. Fail Secure: Default deny
3. Explicit Checks: Never assume permission
4. Service Line Isolation: Users see only their service lines (unless SYSTEM_ADMIN)
5. Input Validation: Zod schemas + `sanitizeObject()`
6. No Information Leakage: Generic error messages

## Performance (REQUIRED)

### Database

- ALWAYS explicit `select:` fields
- NEVER `include` unnecessarily
- Batch queries: `Promise.all()`
- Transactions for multi-step operations
- Indexes for filtered fields
- Prevent N+1 queries

### Caching (Redis)

**TTLs:**
- Sessions: 1h (3600s)
- User/Service Line/Task: 10min (600s)
- Analytics/Static: 30min (1800s)

**Cache Prefixes** (`CACHE_PREFIXES.*`):
- `SESSION`, `RATE_LIMIT`, `USER`, `TASK`, `SERVICE_LINE`, `NOTIFICATION`, `ANALYTICS`

**Note**: Feature permissions are NOT cached (in-memory TypeScript constants, no DB queries)

**Rate Limiting:** `await checkRateLimit(request, RateLimitPresets.STANDARD)`
- Presets: AI_ENDPOINTS (5/min), FILE_UPLOADS (10/min), STANDARD (30/min), READ_ONLY (100/min), AUTH_ENDPOINTS (10/min)

**Background Jobs:** `queue.enqueue(queueType, operation, data, options)` for long tasks
- Queue types: documents, emails, reports
- Never fire-and-forget

### Imports

- Static imports only for core dependencies
- Tree-shakeable exports
- Lazy load heavy dependencies

### Client-Side

- React Query for server state
- Pagination for large datasets
- Server Components default

## Error Handling

- Throw: `new AppError(status, message, ErrorCodes.X, metadata)`
- Catch: `handleApiError(error, context)`
- Codes: VALIDATION_ERROR, NOT_FOUND, FORBIDDEN, UNAUTHORIZED

## Code Quality

- Extract utilities for 3+ uses
- Files under 500 lines
- camelCase file names
- No duplicates, no deprecated code
- Delete .bak/.old immediately
- NO summarization files (e.g., SUMMARY.md, overview.md)
- Business logic in `/src/lib/services/<domain>/`
- Component organization: `ui/`, `layout/`, `shared/`, `features/<domain>/`

## AI Assistant Communication

- Upon task completion, simply state "Completed"
- No verbose summaries or explanations after finishing work
- User can observe progress in real-time

## Core Principles

Security checks are NOT optional. Performance patterns are REQUIRED. Type safety is MANDATORY.
