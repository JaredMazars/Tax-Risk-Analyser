---
alwaysApply: true
---

# Project Conventions

Next.js 14 (App Router) | TypeScript (strict) | Prisma | React Query | Azure OpenAI | Azure AD

## Styling & AI

- Styling: See `.cursor/rules/forvis-design-rules.mdc`
- AI: See `.cursor/rules/ai-patterns.mdc`

## TypeScript

**Type Organization:** Prisma Schema -> `types/index.ts` -> derive DTOs with Partial/Pick/Omit
- `types/branded.ts`: Branded ID types | `types/dto.ts`: DTOs | `types/api.ts`: API types

**Requirements:**
- Strict mode, `@/*` imports, ALL IDs use branded types
- Route params via `parseXxxId()` utilities
- Define enums ONCE in `types/index.ts` (e.g., `SystemRole`, `ServiceLineRole`)
- `undefined` for optional, `null` for database nulls
- **NO `any` types** - Use `unknown`, `Record<string, unknown>`, or proper interfaces
- All input validated via Zod schemas in `/src/lib/validation/schemas.ts`

## Database

**Dual-ID Convention:**
- **Internal IDs** (`id`): Auto-increment PKs for internal-only tables (TaskTeam, BDOpportunity)
- **External IDs** (`GS*`): GUIDs for external system tables (Client, Task, Employee, Wip)
- **Codes** (`*Code`): Display/search ONLY, NEVER for relationships

**Query Patterns:**
```typescript
// External tables: use GS* for relationships
const tasks = await prisma.task.findMany({ where: { GSClientID: client.GSClientID } });

// Internal tables: use id
const team = await prisma.taskTeam.findMany({ where: { taskId: task.id } });

// Codes: search only
const clients = await prisma.client.findMany({ where: { clientCode: { contains: term } } });
```

## Service Lines

**Client-Facing:** TAX, AUDIT, ACCOUNTING, ADVISORY
**Shared Services:** QRM, BUSINESS_DEV, IT, FINANCE, HR

**Tables:**
| Table | Purpose |
|-------|---------|
| `ServiceLineMaster` | Application master list (code, name, active) |
| `ServiceLineExternal` | Maps `ServLineCode` -> `SubServlineGroupCode` -> `masterCode` |
| `ServiceLineUser` | User assignments to `subServiceLineGroup` with `role` |

**Access Pattern:** Task's `ServLineCode` -> `SubServlineGroupCode` -> check user's `ServiceLineUser` assignments

**URL:** `/dashboard/[serviceLine]/[subServiceLineGroup]/clients/[id]/tasks/[taskId]`

## Security (CRITICAL)

### Role Model

1. **System**: `SYSTEM_ADMIN` > `USER`
2. **Service Line**: `ADMINISTRATOR` > `PARTNER` > `MANAGER` > `SUPERVISOR` > `USER` > `VIEWER`

Roles defined in `@/lib/utils/roleHierarchy.ts`. SYSTEM_ADMIN bypasses all checks.

### API Route Pattern (REQUIRED)

```typescript
import { getCurrentUser } from '@/lib/services/auth/auth';
import { checkFeature } from '@/lib/permissions/checkFeature';
import { Feature } from '@/lib/permissions/features';
import { getUserSubServiceLineGroups } from '@/lib/services/service-lines/serviceLineService';
import { enforceRateLimit, RateLimitPresets } from '@/lib/utils/rateLimit';
import { sanitizeObject } from '@/lib/utils/sanitization';
import { logger } from '@/lib/utils/logger';

export async function POST(request: NextRequest) {
  try {
    // 1. Rate limit (REQUIRED for mutations)
    await enforceRateLimit(request, RateLimitPresets.STANDARD);

    // 2. Authenticate
    const user = await getCurrentUser();
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    // 3. Sanitize + Validate (REQUIRED for mutations)
    const body = await request.json();
    const sanitized = sanitizeObject(body);
    const validated = Schema.parse(sanitized);

    // 4. Authorize (Feature OR Service Line access)
    const hasFeature = await checkFeature(user.id, Feature.MANAGE_TASKS);
    const userSubGroups = await getUserSubServiceLineGroups(user.id);
    if (!hasFeature && userSubGroups.length === 0) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    // 5. Execute with explicit select
    const result = await prisma.task.create({
      data: validated,
      select: { id: true, TaskCode: true },
    });

    // 6. Log and respond
    logger.info('Task created', { taskId: result.id });
    return NextResponse.json(successResponse(result));
  } catch (error) {
    return handleApiError(error, 'POST /api/tasks');
  }
}
```

**Or use middleware:**
```typescript
import { withAccess, requireAccess } from '@/lib/api/authMiddleware';

// Middleware wrapper
export const GET = withAccess({
  feature: Feature.ACCESS_TASKS,
  requireServiceLine: true,
}, handler);

// Direct function call
const access = await requireAccess(user.id, { feature: Feature.X, taskId: 123 });
if (!access.allowed) return 403;
```

### Security Checklist

- [ ] `enforceRateLimit()` for ALL mutations (POST/PUT/PATCH/DELETE)
- [ ] `getCurrentUser()` at start
- [ ] `sanitizeObject()` + Zod before processing body
- [ ] `checkFeature()` OR `getUserSubServiceLineGroups()` for access
- [ ] For tasks: `checkTaskAccess(userId, taskId)`
- [ ] Explicit `select:` fields only
- [ ] `handleApiError()` in catch
- [ ] `logger.info/warn/error()` NOT `console.*`

### Rate Limiting

```typescript
import { enforceRateLimit, RateLimitPresets } from '@/lib/utils/rateLimit';

// Presets
await enforceRateLimit(request, RateLimitPresets.STANDARD);     // 30/min
await enforceRateLimit(request, RateLimitPresets.AI_ENDPOINTS); // 5/min
await enforceRateLimit(request, RateLimitPresets.FILE_UPLOADS); // 10/min

// Admin routes: stricter limits
await enforceRateLimit(request, { maxRequests: 20, windowMs: 60000, keyPrefix: 'admin' });
```

### Page-Level Access

**4-Tier Lookup:** Redis Cache -> Database Override -> Code Override -> Convention Default

**Access Levels:** `NONE` (redirect) | `VIEW` (read-only) | `FULL` (all actions)

**Convention Defaults:**
- Admin pages: SYSTEM_ADMIN only
- Analytics/BD: PARTNER+ (MANAGER gets VIEW)
- Regular pages: All roles FULL, VIEWER gets VIEW

**Implementation:**
```typescript
// Layout
import { PageAccessGuard } from '@/components/guards/PageAccessGuard';
<PageAccessGuard pathname={pathname}>{children}</PageAccessGuard>

// Components
const { isViewOnly, canEdit } = usePageAccess();
{isViewOnly && <ViewOnlyBadge />}
<EditActionWrapper><button>Edit</button></EditActionWrapper>
```

### Frontend Security

- `<FeatureGate feature={Feature.X}>` for conditional UI
- `useFeature(Feature.X)` hook for checks
- Server Components default, `'use client'` only when needed
- NEVER use `confirm()`, `alert()`, `prompt()` - use custom modals

## Performance (REQUIRED)

### Imports

- **Static imports ONLY** at top of file - NO `await import()` in handlers
- Exception: AI/ML dependencies may use lazy loading for bundle size

### Database

- ALWAYS explicit `select:` fields
- Batch queries: `Promise.all()`
- Transactions for multi-step operations
- Prevent N+1 queries

### Caching (Redis with fallback)

**TTLs:** Sessions 1h | User/Task 10min | Analytics/Static 30min

**Prefixes:** `CACHE_PREFIXES.SESSION`, `USER`, `TASK`, `SERVICE_LINE`, `ANALYTICS`

Feature permissions are in-memory TypeScript constants (no caching needed).

### Logging

```typescript
import { logger } from '@/lib/utils/logger';

logger.info('Action completed', { userId, taskId });
logger.warn('Unusual condition', { details });
logger.error('Operation failed', error);

// NEVER use console.log/warn/error in production code
```

## Error Handling

```typescript
throw new AppError(status, message, ErrorCodes.X, metadata);
// Catch
return handleApiError(error, 'Context');
```

Codes: `VALIDATION_ERROR`, `NOT_FOUND`, `FORBIDDEN`, `UNAUTHORIZED`

## Code Quality

- Extract utilities for 3+ uses
- Files under 500 lines
- camelCase file names
- No duplicates, no deprecated code
- Business logic in `/src/lib/services/<domain>/`
- Components: `ui/`, `layout/`, `shared/`, `features/<domain>/`

## AI Assistant

- Upon task completion, simply state "Completed"
- No verbose summaries after finishing work

## Core Principles

Security checks are NOT optional. Performance patterns are REQUIRED. Type safety is MANDATORY.
