---
alwaysApply: true
---

# API Patterns

Conventions and patterns for building API routes with Next.js App Router.

## API Route Structure

### File-based Routing

```
/app/api/
├── health/route.ts              # GET /api/health
├── projects/
│   ├── route.ts                 # GET, POST /api/projects
│   └── [id]/
│       ├── route.ts             # GET, PUT, DELETE /api/projects/:id
│       └── users/
│           ├── route.ts         # GET, POST /api/projects/:id/users
│           └── [userId]/
│               └── route.ts     # DELETE /api/projects/:id/users/:userId
└── clients/
    ├── route.ts                 # GET, POST /api/clients
    └── [id]/route.ts            # GET, PUT, DELETE /api/clients/:id
```

### RESTful Conventions

Follow REST conventions for HTTP methods:

| Method | Purpose | Example |
|--------|---------|---------|
| GET | Retrieve resource(s) | `GET /api/projects` |
| POST | Create resource | `POST /api/projects` |
| PUT/PATCH | Update resource | `PUT /api/projects/:id` |
| DELETE | Delete resource | `DELETE /api/projects/:id` |

## Route Handler Template

### Basic Structure

```typescript
// app/api/projects/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db/prisma';
import { handleApiError } from '@/lib/utils/errorHandler';
import { getCurrentUser } from '@/lib/services/auth/auth';
import { CreateProjectSchema } from '@/lib/validation/schemas';
import { successResponse } from '@/lib/utils/apiUtils';

export async function GET(request: NextRequest) {
  try {
    // 1. Authenticate
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 2. Parse query parameters (if needed)
    const { searchParams } = new URL(request.url);
    const filter = searchParams.get('filter');

    // 3. Fetch data
    const projects = await prisma.project.findMany({
      where: { userId: user.id },
      include: { client: true },
    });

    // 4. Return success response
    return NextResponse.json(successResponse(projects));
  } catch (error) {
    return handleApiError(error, 'GET /api/projects');
  }
}

export async function POST(request: NextRequest) {
  try {
    // 1. Authenticate
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 2. Parse and validate body
    const body = await request.json();
    const validated = CreateProjectSchema.parse(body);

    // 3. Create resource
    const project = await prisma.project.create({
      data: {
        ...validated,
        userId: user.id,
      },
    });

    // 4. Return success response with 201
    return NextResponse.json(
      successResponse(project),
      { status: 201 }
    );
  } catch (error) {
    return handleApiError(error, 'POST /api/projects');
  }
}
```

### Dynamic Route Handler

```typescript
// app/api/projects/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { parseProjectId } from '@/lib/utils/apiUtils';

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    // 1. Authenticate
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 2. Parse route parameters (await in App Router)
    const params = await context.params;
    const projectId = parseProjectId(params.id);

    // 3. Check access
    const hasAccess = await checkProjectAccess(user.id, projectId);
    if (!hasAccess) {
      return NextResponse.json(
        { success: false, error: 'Forbidden' },
        { status: 403 }
      );
    }

    // 4. Fetch resource
    const project = await prisma.project.findUnique({
      where: { id: projectId },
    });

    if (!project) {
      return NextResponse.json(
        { success: false, error: 'Project not found' },
        { status: 404 }
      );
    }

    // 5. Return response
    return NextResponse.json(successResponse(project));
  } catch (error) {
    return handleApiError(error, 'GET /api/projects/:id');
  }
}
```

## Authentication Patterns

### Manual Authentication Check

Authentication is **not enforced globally**. Each route handler should check authentication:

```typescript
import { getCurrentUser } from '@/lib/services/auth/auth';

const user = await getCurrentUser();
if (!user) {
  return NextResponse.json(
    { success: false, error: 'Unauthorized' },
    { status: 401 }
  );
}
```

### Middleware Helpers Available (Optional)

The project provides `withAuth` and `withProjectAccess` middleware helpers, but they are **optional**. You can use them for cleaner code or manually check authentication:

```typescript
// Option 1: Manual check (common pattern in codebase)
export async function GET(request: NextRequest) {
  const user = await getCurrentUser();
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  // ... rest of handler
}

// Option 2: Using withAuth middleware (available but not required)
import { withAuth } from '@/lib/api/middleware';

export const GET = withAuth(async (request, { user }) => {
  // user is guaranteed to exist
  // ... handler logic
});

// Option 3: Using withProjectAccess (for project-scoped routes)
import { withProjectAccess } from '@/lib/api/middleware';

export const GET = withProjectAccess()(async (request, { user, params }) => {
  const projectId = parseProjectId(params.id);
  // Access already verified
  // ... handler logic
});
```

**Note**: Most routes in the codebase use manual authentication checks (Option 1). This is the preferred pattern for consistency.

## Authorization Patterns

### Project Access Control

For project-scoped routes, verify user has access:

```typescript
import { checkProjectAccess } from '@/lib/services/auth/auth';

const hasAccess = await checkProjectAccess(
  user.id,
  projectId,
  'ADMIN' // Optional: specific role required
);

if (!hasAccess) {
  return NextResponse.json(
    { success: false, error: 'Forbidden' },
    { status: 403 }
  );
}
```

### Role-based Access

Check for specific roles when needed:

```typescript
// Check if user is project admin
const hasAccess = await checkProjectAccess(user.id, projectId, 'ADMIN');

// Check if user is system admin (from user.roles)
if (!user.roles?.includes('ADMIN')) {
  return NextResponse.json(
    { success: false, error: 'Admin access required' },
    { status: 403 }
  );
}
```

## Request Handling

### Parsing Request Body

```typescript
// JSON body
const body = await request.json();

// FormData (file uploads)
const formData = await request.formData();
const file = formData.get('file') as File;
```

### Query Parameters

```typescript
const { searchParams } = new URL(request.url);

// Single parameter
const filter = searchParams.get('filter');

// Multiple parameters
const page = Number(searchParams.get('page') || '1');
const limit = Number(searchParams.get('limit') || '10');
```

### Route Parameters

```typescript
// Always await params in App Router
const params = await context.params;
const projectId = parseProjectId(params.id);
```

### Headers

```typescript
// Get header
const contentType = request.headers.get('content-type');

// Set response header
return NextResponse.json(data, {
  headers: {
    'Cache-Control': 'no-store',
  },
});
```

## Response Patterns

### Success Response

Use `successResponse` utility:

```typescript
import { successResponse } from '@/lib/utils/apiUtils';

// Single resource
return NextResponse.json(successResponse(project));

// Array of resources
return NextResponse.json(successResponse(projects));

// With custom status
return NextResponse.json(successResponse(project), { status: 201 });
```

Response format:
```json
{
  "success": true,
  "data": { ... }
}
```

### Error Response

Use `handleApiError` for all errors:

```typescript
import { handleApiError } from '@/lib/utils/errorHandler';

try {
  // ... route logic
} catch (error) {
  return handleApiError(error, 'GET /api/projects');
}
```

Error response format:
```json
{
  "success": false,
  "error": "Human-readable message",
  "code": "ERROR_CODE"
}
```

### Manual Error Response

For specific error cases:

```typescript
return NextResponse.json(
  { success: false, error: 'Resource not found' },
  { status: 404 }
);
```

## Validation

### Input Validation

Always validate request body with Zod:

```typescript
import { CreateProjectSchema } from '@/lib/validation/schemas';

const body = await request.json();

// Throws on invalid input (caught by handleApiError)
const validated = CreateProjectSchema.parse(body);

// Or use safeParse for custom error handling
const result = CreateProjectSchema.safeParse(body);
if (!result.success) {
  return NextResponse.json(
    { 
      success: false, 
      error: 'Invalid input',
      details: result.error.flatten()
    },
    { status: 400 }
  );
}
```

### Parameter Validation

Use branded type converters:

```typescript
import { toProjectId, toUserId } from '@/types/branded';

// Throws on invalid ID
const projectId = toProjectId(params.id);
const userId = toUserId(params.userId);
```

## Database Operations

### Query Pattern

```typescript
// Select specific fields
const projects = await prisma.project.findMany({
  where: { userId: user.id },
  select: {
    id: true,
    name: true,
    createdAt: true,
  },
});

// Include relations
const project = await prisma.project.findUnique({
  where: { id: projectId },
  include: {
    client: true,
    ProjectUser: {
      include: {
        User: true,
      },
    },
  },
});
```

### Create Pattern

```typescript
const project = await prisma.project.create({
  data: {
    name: validated.name,
    userId: user.id,
    projectType: validated.projectType,
  },
});
```

### Update Pattern

```typescript
const updated = await prisma.project.update({
  where: { id: projectId },
  data: {
    name: validated.name,
    description: validated.description,
  },
});
```

### Delete Pattern

```typescript
await prisma.project.delete({
  where: { id: projectId },
});

return NextResponse.json(
  { success: true, message: 'Project deleted' }
);
```

### Transaction Pattern

For operations that must succeed or fail together:

```typescript
const result = await prisma.$transaction(async (tx) => {
  const project = await tx.project.update({
    where: { id: projectId },
    data: { status: 'ARCHIVED' },
  });

  await tx.auditLog.create({
    data: {
      action: 'PROJECT_ARCHIVED',
      projectId,
      userId: user.id,
    },
  });

  return project;
});
```

## File Upload Handling

### Multipart Form Data

```typescript
export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json(
        { success: false, error: 'No file provided' },
        { status: 400 }
      );
    }

    // Validate file
    const buffer = Buffer.from(await file.arrayBuffer());
    const fileType = file.name.split('.').pop()?.toLowerCase();

    // Upload to blob storage
    const url = await uploadToBlob(buffer, file.name, projectId);

    return NextResponse.json(successResponse({ url }));
  } catch (error) {
    return handleApiError(error, 'POST /api/upload');
  }
}
```

## Status Codes

Use appropriate HTTP status codes:

| Code | Usage |
|------|-------|
| 200 | Success (GET, PUT, DELETE) |
| 201 | Created (POST) |
| 400 | Bad Request (validation error) |
| 401 | Unauthorized (not authenticated) |
| 403 | Forbidden (authenticated but no access) |
| 404 | Not Found |
| 409 | Conflict (duplicate resource) |
| 429 | Too Many Requests (rate limit) |
| 500 | Internal Server Error |

## Error Handling

### Try-Catch Pattern

Always wrap route logic in try-catch:

```typescript
export async function GET(request: NextRequest) {
  try {
    // Route logic
  } catch (error) {
    return handleApiError(error, 'GET /api/resource');
  }
}
```

### Throwing AppError

For business logic errors:

```typescript
import { AppError, ErrorCodes } from '@/lib/utils/errorHandler';

if (!project) {
  throw new AppError(
    404,
    'Project not found',
    ErrorCodes.NOT_FOUND,
    { projectId }
  );
}
```

## Testing (Future)

When adding tests, structure them alongside routes:

```
api/
└── projects/
    ├── route.ts
    └── route.test.ts
```

## Best Practices

1. **Always authenticate**: Check user in every protected route
2. **Validate input**: Use Zod schemas for all user input
3. **Consistent responses**: Use `successResponse` and `handleApiError`
4. **Appropriate status codes**: Return correct HTTP status
5. **Error context**: Include route name in `handleApiError`
6. **Select fields**: Only fetch needed fields from database
7. **Transaction for multi-step**: Use transactions for related operations
8. **Parse parameters**: Await `context.params` in App Router
9. **Type safety**: Use branded types for IDs
10. **Security**: Never expose sensitive data in responses

## Common Patterns Summary

```typescript
// 1. List resources
export async function GET(request: NextRequest) {
  const user = await getCurrentUser();
  if (!user) return unauthorized();
  
  const resources = await prisma.resource.findMany({
    where: { userId: user.id }
  });
  
  return NextResponse.json(successResponse(resources));
}

// 2. Get single resource
export async function GET(request, { params }) {
  const user = await getCurrentUser();
  if (!user) return unauthorized();
  
  const { id } = await params;
  const resourceId = toResourceId(id);
  
  const hasAccess = await checkAccess(user.id, resourceId);
  if (!hasAccess) return forbidden();
  
  const resource = await prisma.resource.findUnique({
    where: { id: resourceId }
  });
  
  if (!resource) return notFound();
  
  return NextResponse.json(successResponse(resource));
}

// 3. Create resource
export async function POST(request: NextRequest) {
  const user = await getCurrentUser();
  if (!user) return unauthorized();
  
  const body = await request.json();
  const validated = CreateResourceSchema.parse(body);
  
  const resource = await prisma.resource.create({
    data: { ...validated, userId: user.id }
  });
  
  return NextResponse.json(successResponse(resource), { status: 201 });
}

// 4. Update resource
export async function PUT(request, { params }) {
  const user = await getCurrentUser();
  if (!user) return unauthorized();
  
  const { id } = await params;
  const resourceId = toResourceId(id);
  
  const hasAccess = await checkAccess(user.id, resourceId);
  if (!hasAccess) return forbidden();
  
  const body = await request.json();
  const validated = UpdateResourceSchema.parse(body);
  
  const updated = await prisma.resource.update({
    where: { id: resourceId },
    data: validated
  });
  
  return NextResponse.json(successResponse(updated));
}

// 5. Delete resource
export async function DELETE(request, { params }) {
  const user = await getCurrentUser();
  if (!user) return unauthorized();
  
  const { id } = await params;
  const resourceId = toResourceId(id);
  
  const hasAccess = await checkAccess(user.id, resourceId, 'ADMIN');
  if (!hasAccess) return forbidden();
  
  await prisma.resource.delete({
    where: { id: resourceId }
  });
  
  return NextResponse.json({
    success: true,
    message: 'Resource deleted'
  });
}
```
